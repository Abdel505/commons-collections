<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractPatriciaTrie.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Collections</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.collections4.trie</a> &gt; <span class="el_source">AbstractPatriciaTrie.java</span></div><h1>AbstractPatriciaTrie.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.collections4.trie;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.AbstractCollection;
import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Set;
import java.util.SortedMap;

import org.apache.commons.collections4.OrderedMapIterator;
import org.apache.commons.collections4.Trie;

/**
 * This class implements the base PATRICIA algorithm and everything that
 * is related to the {@link Map} interface.
 *
 * @param &lt;K&gt; the type of the keys in this map
 * @param &lt;V&gt; the type of the values in this map
 * @since 4.0
 */
public abstract class AbstractPatriciaTrie&lt;K, V&gt; extends AbstractBitwiseTrie&lt;K, V&gt; {

    /**
     * A range view of the {@link org.apache.commons.collections4.Trie}.
     */
<span class="fc" id="L52">    private abstract class AbstractRangeMap extends AbstractMap&lt;K, V&gt;</span>
            implements SortedMap&lt;K, V&gt; {

        /** The {@link #entrySet()} view. */
        private transient volatile Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;

        @Override
        public Comparator&lt;? super K&gt; comparator() {
<span class="nc" id="L60">            return AbstractPatriciaTrie.this.comparator();</span>
        }

        @Override
        public boolean containsKey(final Object key) {
<span class="fc bfc" id="L65" title="All 2 branches covered.">            if (!inRange(castKey(key))) {</span>
<span class="fc" id="L66">                return false;</span>
            }

<span class="fc" id="L69">            return AbstractPatriciaTrie.this.containsKey(key);</span>
        }

        /**
         * Creates and returns an {@link #entrySet()} view of the {@link AbstractRangeMap}.
         */
        protected abstract Set&lt;Map.Entry&lt;K, V&gt;&gt; createEntrySet();

        /**
         * Creates and returns a sub-range view of the current {@link AbstractRangeMap}.
         */
        protected abstract SortedMap&lt;K, V&gt; createRangeMap(K fromKey, boolean fromInclusive,
                                                          K toKey, boolean toInclusive);

        @Override
        public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() {
<span class="fc bfc" id="L85" title="All 2 branches covered.">            if (entrySet == null) {</span>
<span class="fc" id="L86">                entrySet = createEntrySet();</span>
            }
<span class="fc" id="L88">            return entrySet;</span>
        }

        @Override
        public V get(final Object key) {
<span class="fc bfc" id="L93" title="All 2 branches covered.">            if (!inRange(castKey(key))) {</span>
<span class="fc" id="L94">                return null;</span>
            }

<span class="fc" id="L97">            return AbstractPatriciaTrie.this.get(key);</span>
        }

        /**
         * Gets the FROM Key.
         */
        protected abstract K getFromKey();

        /**
         * Gets the TO Key.
         */
        protected abstract K getToKey();

        @Override
        public SortedMap&lt;K, V&gt; headMap(final K toKey) {
<span class="nc bnc" id="L112" title="All 2 branches missed.">            if (!inRange2(toKey)) {</span>
<span class="nc" id="L113">                throw new IllegalArgumentException(&quot;ToKey is out of range: &quot; + toKey);</span>
            }
<span class="nc" id="L115">            return createRangeMap(getFromKey(), isFromInclusive(), toKey, isToInclusive());</span>
        }

        /**
         * Returns true if the provided key is in the FROM range of the {@link AbstractRangeMap}.
         */
        protected boolean inFromRange(final K key, final boolean forceInclusive) {
<span class="nc" id="L122">            final K fromKey = getFromKey();</span>
<span class="nc" id="L123">            final boolean fromInclusive = isFromInclusive();</span>

<span class="nc" id="L125">            final int ret = getKeyAnalyzer().compare(key, fromKey);</span>
<span class="nc bnc" id="L126" title="All 4 branches missed.">            if (fromInclusive || forceInclusive) {</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">                return ret &gt;= 0;</span>
            }
<span class="nc bnc" id="L129" title="All 2 branches missed.">            return ret &gt; 0;</span>
        }

        /**
         * Returns true if the provided key is greater than TO and less than FROM.
         */
        protected boolean inRange(final K key) {
<span class="nc" id="L136">            final K fromKey = getFromKey();</span>
<span class="nc" id="L137">            final K toKey = getToKey();</span>

<span class="nc bnc" id="L139" title="All 8 branches missed.">            return (fromKey == null || inFromRange(key, false)) &amp;&amp; (toKey == null || inToRange(key, false));</span>
        }

        /**
         * This form allows the high endpoint (as well as all legit keys).
         */
        protected boolean inRange2(final K key) {
<span class="nc" id="L146">            final K fromKey = getFromKey();</span>
<span class="nc" id="L147">            final K toKey = getToKey();</span>

<span class="nc bnc" id="L149" title="All 8 branches missed.">            return (fromKey == null || inFromRange(key, false)) &amp;&amp; (toKey == null || inToRange(key, true));</span>
        }

        /**
         * Returns true if the provided key is in the TO range of the {@link AbstractRangeMap}.
         */
        protected boolean inToRange(final K key, final boolean forceInclusive) {
<span class="nc" id="L156">            final K toKey = getToKey();</span>
<span class="nc" id="L157">            final boolean toInclusive = isToInclusive();</span>

<span class="nc" id="L159">            final int ret = getKeyAnalyzer().compare(key, toKey);</span>
<span class="nc bnc" id="L160" title="All 4 branches missed.">            if (toInclusive || forceInclusive) {</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">                return ret &lt;= 0;</span>
            }
<span class="nc bnc" id="L163" title="All 2 branches missed.">            return ret &lt; 0;</span>
        }

        /**
         * Tests whether or not the {@link #getFromKey()} is in the range.
         *
         * @return whether or not the {@link #getFromKey()} is in the range.
         */
        protected abstract boolean isFromInclusive();

        /**
         * Tests whether or not the {@link #getToKey()} is in the range.
         *
         * @return whether or not the {@link #getToKey()} is in the range.
         */
        protected abstract boolean isToInclusive();

        @Override
        public V put(final K key, final V value) {
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">            if (!inRange(key)) {</span>
<span class="nc" id="L183">                throw new IllegalArgumentException(&quot;Key is out of range: &quot; + key);</span>
            }
<span class="fc" id="L185">            return AbstractPatriciaTrie.this.put(key, value);</span>
        }

        @Override
        public V remove(final Object key) {
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">            if (!inRange(castKey(key))) {</span>
<span class="nc" id="L191">                return null;</span>
            }

<span class="fc" id="L194">            return AbstractPatriciaTrie.this.remove(key);</span>
        }

        @Override
        public SortedMap&lt;K, V&gt; subMap(final K fromKey, final K toKey) {
<span class="nc bnc" id="L199" title="All 2 branches missed.">            if (!inRange2(fromKey)) {</span>
<span class="nc" id="L200">                throw new IllegalArgumentException(&quot;FromKey is out of range: &quot; + fromKey);</span>
            }

<span class="nc bnc" id="L203" title="All 2 branches missed.">            if (!inRange2(toKey)) {</span>
<span class="nc" id="L204">                throw new IllegalArgumentException(&quot;ToKey is out of range: &quot; + toKey);</span>
            }

<span class="nc" id="L207">            return createRangeMap(fromKey, isFromInclusive(), toKey, isToInclusive());</span>
        }

        @Override
        public SortedMap&lt;K, V&gt; tailMap(final K fromKey) {
<span class="nc bnc" id="L212" title="All 2 branches missed.">            if (!inRange2(fromKey)) {</span>
<span class="nc" id="L213">                throw new IllegalArgumentException(&quot;FromKey is out of range: &quot; + fromKey);</span>
            }
<span class="nc" id="L215">            return createRangeMap(fromKey, isFromInclusive(), getToKey(), isToInclusive());</span>
        }
    }

    /**
     * An iterator for the entries.
     */
    abstract class AbstractTrieIterator&lt;E&gt; implements Iterator&lt;E&gt; {

        /** For fast-fail. */
<span class="pc" id="L225">        protected int expectedModCount = AbstractPatriciaTrie.this.modCount;</span>

        protected TrieEntry&lt;K, V&gt; next; // the next node to return
        protected TrieEntry&lt;K, V&gt; current; // the current entry we're on

        /**
         * Starts iteration from the root.
         */
<span class="fc" id="L233">        protected AbstractTrieIterator() {</span>
<span class="fc" id="L234">            next = AbstractPatriciaTrie.this.nextEntry(null);</span>
<span class="fc" id="L235">        }</span>

        /**
         * Starts iteration at the given entry.
         */
<span class="nc" id="L240">        protected AbstractTrieIterator(final TrieEntry&lt;K, V&gt; firstEntry) {</span>
<span class="nc" id="L241">            next = firstEntry;</span>
<span class="nc" id="L242">        }</span>

        /**
         * @see PatriciaTrie#nextEntry(TrieEntry)
         */
        protected TrieEntry&lt;K, V&gt; findNext(final TrieEntry&lt;K, V&gt; prior) {
<span class="fc" id="L248">            return AbstractPatriciaTrie.this.nextEntry(prior);</span>
        }

        @Override
        public boolean hasNext() {
<span class="fc bfc" id="L253" title="All 2 branches covered.">            return next != null;</span>
        }

        /**
         * Returns the next {@link TrieEntry}.
         */
        protected TrieEntry&lt;K, V&gt; nextEntry() {
<span class="fc bfc" id="L260" title="All 2 branches covered.">            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {</span>
<span class="fc" id="L261">                throw new ConcurrentModificationException();</span>
            }

<span class="fc" id="L264">            final TrieEntry&lt;K, V&gt; e = next;</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">            if (e == null) {</span>
<span class="nc" id="L266">                throw new NoSuchElementException();</span>
            }

<span class="fc" id="L269">            next = findNext(e);</span>
<span class="fc" id="L270">            current = e;</span>
<span class="fc" id="L271">            return e;</span>
        }

        @Override
        public void remove() {
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">            if (current == null) {</span>
<span class="nc" id="L277">                throw new IllegalStateException();</span>
            }

<span class="pc bpc" id="L280" title="1 of 2 branches missed.">            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {</span>
<span class="nc" id="L281">                throw new ConcurrentModificationException();</span>
            }

<span class="fc" id="L284">            final TrieEntry&lt;K, V&gt; node = current;</span>
<span class="fc" id="L285">            current = null;</span>
<span class="fc" id="L286">            AbstractPatriciaTrie.this.removeEntry(node);</span>

<span class="fc" id="L288">            expectedModCount = AbstractPatriciaTrie.this.modCount;</span>
<span class="fc" id="L289">        }</span>
    }

    /**
     * This is an entry set view of the {@link org.apache.commons.collections4.Trie} as returned by {@link Map#entrySet()}.
     */
<span class="fc" id="L295">    private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K, V&gt;&gt; {</span>

        /**
         * An {@link Iterator} that returns {@link Entry} Objects.
         */
<span class="fc" id="L300">        private final class EntryIterator extends AbstractTrieIterator&lt;Map.Entry&lt;K, V&gt;&gt; {</span>
            @Override
            public Map.Entry&lt;K, V&gt; next() {
<span class="fc" id="L303">                return nextEntry();</span>
            }
        }

        @Override
        public void clear() {
<span class="fc" id="L309">            AbstractPatriciaTrie.this.clear();</span>
<span class="fc" id="L310">        }</span>

        @Override
        public boolean contains(final Object o) {
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">            if (!(o instanceof Map.Entry)) {</span>
<span class="nc" id="L315">                return false;</span>
            }

<span class="fc" id="L318">            final TrieEntry&lt;K, V&gt; candidate = getEntry(((Map.Entry&lt;?, ?&gt;) o).getKey());</span>
<span class="pc bpc" id="L319" title="1 of 4 branches missed.">            return candidate != null &amp;&amp; candidate.equals(o);</span>
        }

        @Override
        public Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator() {
<span class="fc" id="L324">            return new EntryIterator();</span>
        }

        @Override
        public boolean remove(final Object obj) {
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">            if (!(obj instanceof Map.Entry)) {</span>
<span class="nc" id="L330">                return false;</span>
            }
<span class="fc bfc" id="L332" title="All 2 branches covered.">            if (!contains(obj)) {</span>
<span class="fc" id="L333">                return false;</span>
            }
<span class="fc" id="L335">            final Map.Entry&lt;?, ?&gt; entry = (Map.Entry&lt;?, ?&gt;) obj;</span>
<span class="fc" id="L336">            AbstractPatriciaTrie.this.remove(entry.getKey());</span>
<span class="fc" id="L337">            return true;</span>
        }

        @Override
        public int size() {
<span class="fc" id="L342">            return AbstractPatriciaTrie.this.size();</span>
        }
    }
    /**
     * This is a key set view of the {@link org.apache.commons.collections4.Trie} as returned by {@link Map#keySet()}.
     */
<span class="fc" id="L348">    private final class KeySet extends AbstractSet&lt;K&gt; {</span>

        /**
         * An {@link Iterator} that returns Key Objects.
         */
<span class="fc" id="L353">        private final class KeyIterator extends AbstractTrieIterator&lt;K&gt; {</span>
            @Override
            public K next() {
<span class="fc" id="L356">                return nextEntry().getKey();</span>
            }
        }

        @Override
        public void clear() {
<span class="fc" id="L362">            AbstractPatriciaTrie.this.clear();</span>
<span class="fc" id="L363">        }</span>

        @Override
        public boolean contains(final Object o) {
<span class="fc" id="L367">            return containsKey(o);</span>
        }

        @Override
        public Iterator&lt;K&gt; iterator() {
<span class="fc" id="L372">            return new KeyIterator();</span>
        }

        @Override
        public boolean remove(final Object o) {
<span class="fc" id="L377">            final int size = size();</span>
<span class="fc" id="L378">            AbstractPatriciaTrie.this.remove(o);</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">            return size != size();</span>
        }

        @Override
        public int size() {
<span class="fc" id="L384">            return AbstractPatriciaTrie.this.size();</span>
        }
    }
    /**
     * A prefix {@link RangeEntrySet} view of the {@link org.apache.commons.collections4.Trie}.
     */
    private final class PrefixRangeEntrySet extends RangeEntrySet {

        /**
         * An {@link Iterator} for iterating over a prefix search.
         */
        private final class EntryIterator extends AbstractTrieIterator&lt;Map.Entry&lt;K, V&gt;&gt; {

            // values to reset the subtree if we remove it.
            private final K prefix;
            private final int offset;
            private final int lengthInBits;
            private boolean lastOne;

            private TrieEntry&lt;K, V&gt; subtree; // the subtree to search within

            /**
             * Starts iteration at the given entry &amp;amp; search only
             * within the given subtree.
             */
            EntryIterator(final TrieEntry&lt;K, V&gt; startScan, final K prefix,
<span class="fc" id="L410">                    final int offset, final int lengthInBits) {</span>
<span class="fc" id="L411">                subtree = startScan;</span>
<span class="fc" id="L412">                next = AbstractPatriciaTrie.this.followLeft(startScan);</span>
<span class="fc" id="L413">                this.prefix = prefix;</span>
<span class="fc" id="L414">                this.offset = offset;</span>
<span class="fc" id="L415">                this.lengthInBits = lengthInBits;</span>
<span class="fc" id="L416">            }</span>

            @Override
            protected TrieEntry&lt;K, V&gt; findNext(final TrieEntry&lt;K, V&gt; prior) {
<span class="fc" id="L420">                return AbstractPatriciaTrie.this.nextEntryInSubtree(prior, subtree);</span>
            }

            @Override
            public Map.Entry&lt;K, V&gt; next() {
<span class="fc" id="L425">                final Map.Entry&lt;K, V&gt; entry = nextEntry();</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">                if (lastOne) {</span>
<span class="fc" id="L427">                    next = null;</span>
                }
<span class="fc" id="L429">                return entry;</span>
            }

            @Override
            public void remove() {
                // If the current entry we're removing is the subtree
                // then we need to find a new subtree parent.
<span class="fc" id="L436">                boolean needsFixing = false;</span>
<span class="fc" id="L437">                final int bitIdx = subtree.bitIndex;</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">                if (current == subtree) {</span>
<span class="fc" id="L439">                    needsFixing = true;</span>
                }

<span class="fc" id="L442">                super.remove();</span>

                // If the subtree changed its bitIndex or we
                // removed the old subtree, get a new one.
<span class="pc bpc" id="L446" title="1 of 4 branches missed.">                if (bitIdx != subtree.bitIndex || needsFixing) {</span>
<span class="fc" id="L447">                    subtree = subtree(prefix, offset, lengthInBits);</span>
                }

                // If the subtree's bitIndex is less than the
                // length of our prefix, it's the last item
                // in the prefix tree.
<span class="fc bfc" id="L453" title="All 2 branches covered.">                if (lengthInBits &gt;= subtree.bitIndex) {</span>
<span class="fc" id="L454">                    lastOne = true;</span>
                }
<span class="fc" id="L456">            }</span>
        }

        /**
         * An {@link Iterator} that holds a single {@link TrieEntry}.
         */
        private final class SingletonIterator implements Iterator&lt;Map.Entry&lt;K, V&gt;&gt; {

            private final TrieEntry&lt;K, V&gt; entry;

            private int hit;

<span class="fc" id="L468">            SingletonIterator(final TrieEntry&lt;K, V&gt; entry) {</span>
<span class="fc" id="L469">                this.entry = entry;</span>
<span class="fc" id="L470">            }</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L474" title="All 2 branches covered.">                return hit == 0;</span>
            }

            @Override
            public Map.Entry&lt;K, V&gt; next() {
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">                if (hit != 0) {</span>
<span class="nc" id="L480">                    throw new NoSuchElementException();</span>
                }

<span class="fc" id="L483">                ++hit;</span>
<span class="fc" id="L484">                return entry;</span>
            }

            @Override
            public void remove() {
<span class="nc bnc" id="L489" title="All 2 branches missed.">                if (hit != 1) {</span>
<span class="nc" id="L490">                    throw new IllegalStateException();</span>
                }

<span class="nc" id="L493">                ++hit;</span>
<span class="nc" id="L494">                AbstractPatriciaTrie.this.removeEntry(entry);</span>
<span class="nc" id="L495">            }</span>
        }

        private final PrefixRangeMap delegate;

        private TrieEntry&lt;K, V&gt; prefixStart;

        private int expectedModCount;

        /**
         * Creates a {@link PrefixRangeEntrySet}.
         */
<span class="fc" id="L507">        PrefixRangeEntrySet(final PrefixRangeMap delegate) {</span>
<span class="fc" id="L508">            super(delegate);</span>
<span class="fc" id="L509">            this.delegate = delegate;</span>
<span class="fc" id="L510">        }</span>

        @Override
        public Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator() {
<span class="fc bfc" id="L514" title="All 2 branches covered.">            if (AbstractPatriciaTrie.this.modCount != expectedModCount) {</span>
<span class="fc" id="L515">                prefixStart = subtree(delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);</span>
<span class="fc" id="L516">                expectedModCount = AbstractPatriciaTrie.this.modCount;</span>
            }

<span class="fc bfc" id="L519" title="All 2 branches covered.">            if (prefixStart == null) {</span>
<span class="fc" id="L520">                final Set&lt;Map.Entry&lt;K, V&gt;&gt; empty = Collections.emptySet();</span>
<span class="fc" id="L521">                return empty.iterator();</span>
            }
<span class="fc bfc" id="L523" title="All 2 branches covered.">            if (delegate.lengthInBits &gt; prefixStart.bitIndex) {</span>
<span class="fc" id="L524">                return new SingletonIterator(prefixStart);</span>
            }
<span class="fc" id="L526">            return new EntryIterator(prefixStart, delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);</span>
        }

        @Override
        public int size() {
<span class="fc" id="L531">            return delegate.fixup();</span>
        }
    }

    /**
     * A submap used for prefix views over the {@link org.apache.commons.collections4.Trie}.
     */
    private final class PrefixRangeMap extends AbstractRangeMap {

        private final K prefix;

        private final int offsetInBits;

        private final int lengthInBits;

        private K fromKey;

        private K toKey;

        private transient int expectedModCount;

<span class="fc" id="L552">        private int size = -1;</span>

        /**
         * Creates a {@link PrefixRangeMap}.
         */
<span class="fc" id="L557">        private PrefixRangeMap(final K prefix, final int offsetInBits, final int lengthInBits) {</span>
<span class="fc" id="L558">            this.prefix = prefix;</span>
<span class="fc" id="L559">            this.offsetInBits = offsetInBits;</span>
<span class="fc" id="L560">            this.lengthInBits = lengthInBits;</span>
<span class="fc" id="L561">        }</span>

        @Override
        public void clear() {
<span class="fc" id="L565">            final Iterator&lt;Map.Entry&lt;K, V&gt;&gt; it = AbstractPatriciaTrie.this.entrySet().iterator();</span>
<span class="fc" id="L566">            final Set&lt;K&gt; currentKeys = keySet();</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">            while (it.hasNext()) {</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">                if (currentKeys.contains(it.next().getKey())) {</span>
<span class="fc" id="L569">                    it.remove();</span>
                }
            }
<span class="fc" id="L572">        }</span>

        @Override
        protected Set&lt;Map.Entry&lt;K, V&gt;&gt; createEntrySet() {
<span class="fc" id="L576">            return new PrefixRangeEntrySet(this);</span>
        }

        @Override
        protected SortedMap&lt;K, V&gt; createRangeMap(final K fromKey, final boolean fromInclusive,
                                                 final K toKey, final boolean toInclusive) {
<span class="nc" id="L582">            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);</span>
        }

        @Override
        public K firstKey() {
<span class="fc" id="L587">            fixup();</span>

<span class="fc" id="L589">            Map.Entry&lt;K, V&gt; e = null;</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">            if (fromKey == null) {</span>
<span class="fc" id="L591">                e = firstEntry();</span>
            } else {
<span class="fc" id="L593">                e = higherEntry(fromKey);</span>
            }

<span class="pc bpc" id="L596" title="1 of 2 branches missed.">            final K first = e != null ? e.getKey() : null;</span>
<span class="pc bpc" id="L597" title="1 of 4 branches missed.">            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, first)) {</span>
<span class="fc" id="L598">                throw new NoSuchElementException();</span>
            }

<span class="fc" id="L601">            return first;</span>
        }

        /**
         * This method does two things. It determines the FROM
         * and TO range of the {@link PrefixRangeMap} and the number
         * of elements in the range. This method must be called every
         * time the {@link org.apache.commons.collections4.Trie} has changed.
         */
        private int fixup() {
            // The trie has changed since we last found our toKey / fromKey
<span class="fc bfc" id="L612" title="All 4 branches covered.">            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {</span>
<span class="fc" id="L613">                final Iterator&lt;Map.Entry&lt;K, V&gt;&gt; it = super.entrySet().iterator();</span>
<span class="fc" id="L614">                size = 0;</span>

<span class="fc" id="L616">                Map.Entry&lt;K, V&gt; entry = null;</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">                if (it.hasNext()) {</span>
<span class="fc" id="L618">                    entry = it.next();</span>
<span class="fc" id="L619">                    size = 1;</span>
                }

<span class="fc bfc" id="L622" title="All 2 branches covered.">                fromKey = entry == null ? null : entry.getKey();</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">                if (fromKey != null) {</span>
<span class="fc" id="L624">                    final TrieEntry&lt;K, V&gt; prior = previousEntry((TrieEntry&lt;K, V&gt;) entry);</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">                    fromKey = prior == null ? null : prior.getKey();</span>
                }

<span class="fc" id="L628">                toKey = fromKey;</span>

<span class="fc bfc" id="L630" title="All 2 branches covered.">                while (it.hasNext()) {</span>
<span class="fc" id="L631">                    ++size;</span>
<span class="fc" id="L632">                    entry = it.next();</span>
                }

<span class="fc bfc" id="L635" title="All 2 branches covered.">                toKey = entry == null ? null : entry.getKey();</span>

<span class="fc bfc" id="L637" title="All 2 branches covered.">                if (toKey != null) {</span>
<span class="fc" id="L638">                    entry = nextEntry((TrieEntry&lt;K, V&gt;) entry);</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">                    toKey = entry == null ? null : entry.getKey();</span>
                }

<span class="fc" id="L642">                expectedModCount = AbstractPatriciaTrie.this.modCount;</span>
            }

<span class="fc" id="L645">            return size;</span>
        }

        @Override
        public K getFromKey() {
<span class="nc" id="L650">            return fromKey;</span>
        }

        @Override
        public K getToKey() {
<span class="nc" id="L655">            return toKey;</span>
        }

        /**
         * Returns true if the provided Key is in the FROM range of the {@link PrefixRangeMap}.
         */
        @Override
        protected boolean inFromRange(final K key, final boolean forceInclusive) {
<span class="nc" id="L663">            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);</span>
        }

        /**
         * Returns true if this {@link PrefixRangeMap}'s key is a prefix of the provided key.
         */
        @Override
        protected boolean inRange(final K key) {
<span class="fc" id="L671">            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);</span>
        }

        /**
         * Same as {@link #inRange(Object)}.
         */
        @Override
        protected boolean inRange2(final K key) {
<span class="nc" id="L679">            return inRange(key);</span>
        }

        /**
         * Returns true if the provided Key is in the TO range of the {@link PrefixRangeMap}.
         */
        @Override
        protected boolean inToRange(final K key, final boolean forceInclusive) {
<span class="nc" id="L687">            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);</span>
        }

        @Override
        public boolean isFromInclusive() {
<span class="nc" id="L692">            return false;</span>
        }

        @Override
        public boolean isToInclusive() {
<span class="nc" id="L697">            return false;</span>
        }

        @Override
        public K lastKey() {
<span class="fc" id="L702">            fixup();</span>

<span class="fc" id="L704">            Map.Entry&lt;K, V&gt; e = null;</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">            if (toKey == null) {</span>
<span class="fc" id="L706">                e = lastEntry();</span>
            } else {
<span class="fc" id="L708">                e = lowerEntry(toKey);</span>
            }

<span class="pc bpc" id="L711" title="1 of 2 branches missed.">            final K last = e != null ? e.getKey() : null;</span>
<span class="pc bpc" id="L712" title="1 of 4 branches missed.">            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, last)) {</span>
<span class="fc" id="L713">                throw new NoSuchElementException();</span>
            }

<span class="fc" id="L716">            return last;</span>
        }
    }

    /**
     * A {@link AbstractRangeMap} that deals with {@link Entry}s.
     */
    private final class RangeEntryMap extends AbstractRangeMap {

        /** The key to start from, null if the beginning. */
        private final K fromKey;

        /** The key to end at, null if till the end. */
        private final K toKey;

        /** Whether or not the 'from' is inclusive. */
        private final boolean fromInclusive;

        /** Whether or not the 'to' is inclusive. */
        private final boolean toInclusive;

        /**
         * Creates a {@link RangeEntryMap}.
         */
        protected RangeEntryMap(final K fromKey, final boolean fromInclusive,
<span class="nc" id="L741">                                final K toKey, final boolean toInclusive) {</span>

<span class="nc bnc" id="L743" title="All 4 branches missed.">            if (fromKey == null &amp;&amp; toKey == null) {</span>
<span class="nc" id="L744">                throw new IllegalArgumentException(&quot;must have a from or to!&quot;);</span>
            }

<span class="nc bnc" id="L747" title="All 6 branches missed.">            if (fromKey != null &amp;&amp; toKey != null &amp;&amp; getKeyAnalyzer().compare(fromKey, toKey) &gt; 0) {</span>
<span class="nc" id="L748">                throw new IllegalArgumentException(&quot;fromKey &gt; toKey&quot;);</span>
            }

<span class="nc" id="L751">            this.fromKey = fromKey;</span>
<span class="nc" id="L752">            this.fromInclusive = fromInclusive;</span>
<span class="nc" id="L753">            this.toKey = toKey;</span>
<span class="nc" id="L754">            this.toInclusive = toInclusive;</span>
<span class="nc" id="L755">        }</span>

        /**
         * Creates a {@link RangeEntryMap} with the fromKey included and
         * the toKey excluded from the range.
         */
        protected RangeEntryMap(final K fromKey, final K toKey) {
<span class="nc" id="L762">            this(fromKey, true, toKey, false);</span>
<span class="nc" id="L763">        }</span>

        @Override
        protected Set&lt;Entry&lt;K, V&gt;&gt; createEntrySet() {
<span class="nc" id="L767">            return new RangeEntrySet(this);</span>
        }

        @Override
        protected SortedMap&lt;K, V&gt; createRangeMap(final K fromKey, final boolean fromInclusive,
                                                 final K toKey, final boolean toInclusive) {
<span class="nc" id="L773">            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);</span>
        }

        @Override
        public K firstKey() {
<span class="nc" id="L778">            Map.Entry&lt;K, V&gt; e = null;</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">            if (fromKey == null) {</span>
<span class="nc" id="L780">                e = firstEntry();</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">            } else if (fromInclusive) {</span>
<span class="nc" id="L782">                e = ceilingEntry(fromKey);</span>
            } else {
<span class="nc" id="L784">                e = higherEntry(fromKey);</span>
            }

<span class="nc bnc" id="L787" title="All 2 branches missed.">            final K first = e != null ? e.getKey() : null;</span>
<span class="nc bnc" id="L788" title="All 6 branches missed.">            if (e == null || toKey != null &amp;&amp; !inToRange(first, false)) {</span>
<span class="nc" id="L789">                throw new NoSuchElementException();</span>
            }
<span class="nc" id="L791">            return first;</span>
        }

        @Override
        public K getFromKey() {
<span class="nc" id="L796">            return fromKey;</span>
        }

        @Override
        public K getToKey() {
<span class="nc" id="L801">            return toKey;</span>
        }

        @Override
        public boolean isFromInclusive() {
<span class="nc" id="L806">            return fromInclusive;</span>
        }

        @Override
        public boolean isToInclusive() {
<span class="nc" id="L811">            return toInclusive;</span>
        }

        @Override
        public K lastKey() {
            final Map.Entry&lt;K, V&gt; e;
<span class="nc bnc" id="L817" title="All 2 branches missed.">            if (toKey == null) {</span>
<span class="nc" id="L818">                e = lastEntry();</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">            } else if (toInclusive) {</span>
<span class="nc" id="L820">                e = floorEntry(toKey);</span>
            } else {
<span class="nc" id="L822">                e = lowerEntry(toKey);</span>
            }

<span class="nc bnc" id="L825" title="All 2 branches missed.">            final K last = e != null ? e.getKey() : null;</span>
<span class="nc bnc" id="L826" title="All 6 branches missed.">            if (e == null || fromKey != null &amp;&amp; !inFromRange(last, false)) {</span>
<span class="nc" id="L827">                throw new NoSuchElementException();</span>
            }
<span class="nc" id="L829">            return last;</span>
        }
    }

    /**
     * A {@link Set} view of a {@link AbstractRangeMap}.
     */
    private class RangeEntrySet extends AbstractSet&lt;Map.Entry&lt;K, V&gt;&gt; {

        /**
         * An {@link Iterator} for {@link RangeEntrySet}s.
         */
        private final class EntryIterator extends AbstractTrieIterator&lt;Map.Entry&lt;K, V&gt;&gt; {

            private final K excludedKey;

            /**
             * Creates a {@link EntryIterator}.
             */
<span class="nc" id="L848">            private EntryIterator(final TrieEntry&lt;K, V&gt; first, final TrieEntry&lt;K, V&gt; last) {</span>
<span class="nc" id="L849">                super(first);</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">                this.excludedKey = last != null ? last.getKey() : null;</span>
<span class="nc" id="L851">            }</span>

            @Override
            public boolean hasNext() {
<span class="nc bnc" id="L855" title="All 4 branches missed.">                return next != null &amp;&amp; !compare(next.key, excludedKey);</span>
            }

            @Override
            public Map.Entry&lt;K, V&gt; next() {
<span class="nc bnc" id="L860" title="All 4 branches missed.">                if (next == null || compare(next.key, excludedKey)) {</span>
<span class="nc" id="L861">                    throw new NoSuchElementException();</span>
                }
<span class="nc" id="L863">                return nextEntry();</span>
            }
        }

        private final AbstractRangeMap delegate;

<span class="fc" id="L869">        private transient int size = -1;</span>

        private transient int expectedModCount;

        /**
         * Creates a {@link RangeEntrySet}.
         */
<span class="fc" id="L876">        RangeEntrySet(final AbstractRangeMap delegate) {</span>
<span class="fc" id="L877">            this.delegate = Objects.requireNonNull(delegate, &quot;delegate&quot;);</span>
<span class="fc" id="L878">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public boolean contains(final Object o) {
<span class="nc bnc" id="L883" title="All 2 branches missed.">            if (!(o instanceof Map.Entry)) {</span>
<span class="nc" id="L884">                return false;</span>
            }

<span class="nc" id="L887">            final Map.Entry&lt;K, V&gt; entry = (Map.Entry&lt;K, V&gt;) o;</span>
<span class="nc" id="L888">            final K key = entry.getKey();</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">            if (!delegate.inRange(key)) {</span>
<span class="nc" id="L890">                return false;</span>
            }

<span class="nc" id="L893">            final TrieEntry&lt;K, V&gt; node = getEntry(key);</span>
<span class="nc bnc" id="L894" title="All 4 branches missed.">            return node != null &amp;&amp; compare(node.getValue(), entry.getValue());</span>
        }

        @Override
        public boolean isEmpty() {
<span class="nc bnc" id="L899" title="All 2 branches missed.">            return !iterator().hasNext();</span>
        }

        @Override
        public Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator() {
<span class="nc" id="L904">            final K fromKey = delegate.getFromKey();</span>
<span class="nc" id="L905">            final K toKey = delegate.getToKey();</span>

<span class="nc" id="L907">            TrieEntry&lt;K, V&gt; first = null;</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">            if (fromKey == null) {</span>
<span class="nc" id="L909">                first = firstEntry();</span>
            } else {
<span class="nc" id="L911">                first = ceilingEntry(fromKey);</span>
            }

<span class="nc" id="L914">            TrieEntry&lt;K, V&gt; last = null;</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">            if (toKey != null) {</span>
<span class="nc" id="L916">                last = ceilingEntry(toKey);</span>
            }

<span class="nc" id="L919">            return new EntryIterator(first, last);</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public boolean remove(final Object o) {
<span class="nc bnc" id="L925" title="All 2 branches missed.">            if (!(o instanceof Map.Entry)) {</span>
<span class="nc" id="L926">                return false;</span>
            }

<span class="nc" id="L929">            final Map.Entry&lt;K, V&gt; entry = (Map.Entry&lt;K, V&gt;) o;</span>
<span class="nc" id="L930">            final K key = entry.getKey();</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">            if (!delegate.inRange(key)) {</span>
<span class="nc" id="L932">                return false;</span>
            }

<span class="nc" id="L935">            final TrieEntry&lt;K, V&gt; node = getEntry(key);</span>
<span class="nc bnc" id="L936" title="All 4 branches missed.">            if (node != null &amp;&amp; compare(node.getValue(), entry.getValue())) {</span>
<span class="nc" id="L937">                removeEntry(node);</span>
<span class="nc" id="L938">                return true;</span>
            }
<span class="nc" id="L940">            return false;</span>
        }

        @Override
        public int size() {
<span class="nc bnc" id="L945" title="All 4 branches missed.">            if (size == -1 || expectedModCount != AbstractPatriciaTrie.this.modCount) {</span>
<span class="nc" id="L946">                size = 0;</span>

<span class="nc bnc" id="L948" title="All 2 branches missed.">                for (final Iterator&lt;?&gt; it = iterator(); it.hasNext(); it.next()) {</span>
<span class="nc" id="L949">                    ++size;</span>
                }

<span class="nc" id="L952">                expectedModCount = AbstractPatriciaTrie.this.modCount;</span>
            }
<span class="nc" id="L954">            return size;</span>
        }
    }

    /**
     * A {@link Reference} allows us to return something through a Method's
     * argument list. An alternative would be to an Array with a length of
     * one (1) but that leads to compiler warnings. Computationally and memory
     * wise there's no difference (except for the need to load the
     * {@link Reference} Class but that happens only once).
     */
    private static final class Reference&lt;E&gt; {

        private E item;

        public E get() {
<span class="nc" id="L970">            return item;</span>
        }

        public void set(final E item) {
<span class="nc" id="L974">            this.item = item;</span>
<span class="nc" id="L975">        }</span>
    }

    /**
     * A {@link org.apache.commons.collections4.Trie} is a set of {@link TrieEntry} nodes.
     *
     * @param &lt;K&gt; the key type.
     * @param &lt;V&gt; the value type.
     */
    protected static class TrieEntry&lt;K, V&gt; extends BasicEntry&lt;K, V&gt; {

        private static final long serialVersionUID = 4596023148184140013L;

        /** The index this entry is comparing. */
        protected int bitIndex;

        /** The parent of this entry. */
        protected TrieEntry&lt;K, V&gt; parent;

        /** The left child of this entry. */
        protected TrieEntry&lt;K, V&gt; left;

        /** The right child of this entry. */
        protected TrieEntry&lt;K, V&gt; right;

        /** The entry who uplinks to this entry. */
        protected TrieEntry&lt;K, V&gt; predecessor;

        /**
         * Constructs a new instance.
         *
         * @param key The entry's key.
         * @param value The entry's value.
         * @param bitIndex The entry's bitIndex.
         */
        public TrieEntry(final K key, final V value, final int bitIndex) {
<span class="fc" id="L1011">            super(key, value);</span>
<span class="fc" id="L1012">            this.bitIndex = bitIndex;</span>
<span class="fc" id="L1013">            this.parent = null;</span>
<span class="fc" id="L1014">            this.left = this;</span>
<span class="fc" id="L1015">            this.right = null;</span>
<span class="fc" id="L1016">            this.predecessor = this;</span>
<span class="fc" id="L1017">        }</span>

        /**
         * Tests whether the entry is storing a key. Only the root can potentially be empty, all other nodes must have a key.
         *
         * @return Whether the entry is storing a key
         */
        public boolean isEmpty() {
<span class="fc bfc" id="L1025" title="All 2 branches covered.">            return key == null;</span>
        }

        /**
         * Tests whether the left or right child is a loopback.
         *
         * @return Whether the left or right child is a loopback.
         */
        public boolean isExternalNode() {
<span class="pc bpc" id="L1034" title="1 of 2 branches missed.">            return !isInternalNode();</span>
        }

        /**
         * Tests that neither the left nor right child is a loopback.
         *
         * @return That neither the left nor right child is a loopback.
         */
        public boolean isInternalNode() {
<span class="fc bfc" id="L1043" title="All 4 branches covered.">            return left != this &amp;&amp; right != this;</span>
        }

        @Override
        public String toString() {
<span class="fc" id="L1048">            final StringBuilder buffer = new StringBuilder();</span>

<span class="pc bpc" id="L1050" title="1 of 2 branches missed.">            if (bitIndex == -1) {</span>
<span class="nc" id="L1051">                buffer.append(&quot;RootEntry(&quot;);</span>
            } else {
<span class="fc" id="L1053">                buffer.append(&quot;Entry(&quot;);</span>
            }

<span class="fc" id="L1056">            buffer.append(&quot;key=&quot;).append(getKey()).append(&quot; [&quot;).append(bitIndex).append(&quot;], &quot;);</span>
<span class="fc" id="L1057">            buffer.append(&quot;value=&quot;).append(getValue()).append(&quot;, &quot;);</span>
            //buffer.append(&quot;bitIndex=&quot;).append(bitIndex).append(&quot;, &quot;);

<span class="pc bpc" id="L1060" title="1 of 2 branches missed.">            if (parent != null) {</span>
<span class="fc bfc" id="L1061" title="All 2 branches covered.">                if (parent.bitIndex == -1) {</span>
<span class="fc" id="L1062">                    buffer.append(&quot;parent=&quot;).append(&quot;ROOT&quot;);</span>
                } else {
<span class="fc" id="L1064">                    buffer.append(&quot;parent=&quot;).append(parent.getKey()).append(&quot; [&quot;).append(parent.bitIndex).append(&quot;]&quot;);</span>
                }
            } else {
<span class="nc" id="L1067">                buffer.append(&quot;parent=&quot;).append(&quot;null&quot;);</span>
            }
<span class="fc" id="L1069">            buffer.append(&quot;, &quot;);</span>

<span class="pc bpc" id="L1071" title="1 of 2 branches missed.">            if (left != null) {</span>
<span class="fc bfc" id="L1072" title="All 2 branches covered.">                if (left.bitIndex == -1) {</span>
<span class="fc" id="L1073">                    buffer.append(&quot;left=&quot;).append(&quot;ROOT&quot;);</span>
                } else {
<span class="fc" id="L1075">                    buffer.append(&quot;left=&quot;).append(left.getKey()).append(&quot; [&quot;).append(left.bitIndex).append(&quot;]&quot;);</span>
                }
            } else {
<span class="nc" id="L1078">                buffer.append(&quot;left=&quot;).append(&quot;null&quot;);</span>
            }
<span class="fc" id="L1080">            buffer.append(&quot;, &quot;);</span>

<span class="pc bpc" id="L1082" title="1 of 2 branches missed.">            if (right != null) {</span>
<span class="pc bpc" id="L1083" title="1 of 2 branches missed.">                if (right.bitIndex == -1) {</span>
<span class="nc" id="L1084">                    buffer.append(&quot;right=&quot;).append(&quot;ROOT&quot;);</span>
                } else {
<span class="fc" id="L1086">                    buffer.append(&quot;right=&quot;).append(right.getKey()).append(&quot; [&quot;).append(right.bitIndex).append(&quot;]&quot;);</span>
                }
            } else {
<span class="nc" id="L1089">                buffer.append(&quot;right=&quot;).append(&quot;null&quot;);</span>
            }
<span class="fc" id="L1091">            buffer.append(&quot;, &quot;);</span>

<span class="pc bpc" id="L1093" title="1 of 2 branches missed.">            if (predecessor != null) {</span>
<span class="pc bpc" id="L1094" title="1 of 2 branches missed.">                if (predecessor.bitIndex == -1) {</span>
<span class="nc" id="L1095">                    buffer.append(&quot;predecessor=&quot;).append(&quot;ROOT&quot;);</span>
                } else {
<span class="fc" id="L1097">                    buffer.append(&quot;predecessor=&quot;).append(predecessor.getKey()).append(&quot; [&quot;).</span>
<span class="fc" id="L1098">                           append(predecessor.bitIndex).append(&quot;]&quot;);</span>
                }
            }

<span class="fc" id="L1102">            buffer.append(&quot;)&quot;);</span>
<span class="fc" id="L1103">            return buffer.toString();</span>
        }
    }

    /**
     * An {@link OrderedMapIterator} for a {@link org.apache.commons.collections4.Trie}.
     */
<span class="nc" id="L1110">    private final class TrieMapIterator extends AbstractTrieIterator&lt;K&gt; implements OrderedMapIterator&lt;K, V&gt; {</span>

        protected TrieEntry&lt;K, V&gt; previous; // the previous node to return

        @Override
        public K getKey() {
<span class="nc bnc" id="L1116" title="All 2 branches missed.">            if (current == null) {</span>
<span class="nc" id="L1117">                throw new IllegalStateException();</span>
            }
<span class="nc" id="L1119">            return current.getKey();</span>
        }

        @Override
        public V getValue() {
<span class="nc bnc" id="L1124" title="All 2 branches missed.">            if (current == null) {</span>
<span class="nc" id="L1125">                throw new IllegalStateException();</span>
            }
<span class="nc" id="L1127">            return current.getValue();</span>
        }

        @Override
        public boolean hasPrevious() {
<span class="nc bnc" id="L1132" title="All 2 branches missed.">            return previous != null;</span>
        }

        @Override
        public K next() {
<span class="nc" id="L1137">            return nextEntry().getKey();</span>
        }

        @Override
        protected TrieEntry&lt;K, V&gt; nextEntry() {
<span class="nc" id="L1142">            final TrieEntry&lt;K, V&gt; nextEntry = super.nextEntry();</span>
<span class="nc" id="L1143">            previous = nextEntry;</span>
<span class="nc" id="L1144">            return nextEntry;</span>
        }

        @Override
        public K previous() {
<span class="nc" id="L1149">            return previousEntry().getKey();</span>
        }

        protected TrieEntry&lt;K, V&gt; previousEntry() {
<span class="nc bnc" id="L1153" title="All 2 branches missed.">            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {</span>
<span class="nc" id="L1154">                throw new ConcurrentModificationException();</span>
            }

<span class="nc" id="L1157">            final TrieEntry&lt;K, V&gt; e = previous;</span>
<span class="nc bnc" id="L1158" title="All 2 branches missed.">            if (e == null) {</span>
<span class="nc" id="L1159">                throw new NoSuchElementException();</span>
            }

<span class="nc" id="L1162">            previous = AbstractPatriciaTrie.this.previousEntry(e);</span>
<span class="nc" id="L1163">            next = current;</span>
<span class="nc" id="L1164">            current = e;</span>
<span class="nc" id="L1165">            return current;</span>
        }

        @Override
        public V setValue(final V value) {
<span class="nc bnc" id="L1170" title="All 2 branches missed.">            if (current == null) {</span>
<span class="nc" id="L1171">                throw new IllegalStateException();</span>
            }
<span class="nc" id="L1173">            return current.setValue(value);</span>
        }

    }

    /**
     * This is a value view of the {@link org.apache.commons.collections4.Trie} as returned by {@link Map#values()}.
     */
<span class="fc" id="L1181">    private final class Values extends AbstractCollection&lt;V&gt; {</span>

        /**
         * An {@link Iterator} that returns Value Objects.
         */
<span class="fc" id="L1186">        private final class ValueIterator extends AbstractTrieIterator&lt;V&gt; {</span>
            @Override
            public V next() {
<span class="fc" id="L1189">                return nextEntry().getValue();</span>
            }
        }

        @Override
        public void clear() {
<span class="fc" id="L1195">            AbstractPatriciaTrie.this.clear();</span>
<span class="fc" id="L1196">        }</span>

        @Override
        public boolean contains(final Object o) {
<span class="fc" id="L1200">            return containsValue(o);</span>
        }

        @Override
        public Iterator&lt;V&gt; iterator() {
<span class="fc" id="L1205">            return new ValueIterator();</span>
        }

        @Override
        public boolean remove(final Object o) {
<span class="pc bpc" id="L1210" title="1 of 2 branches missed.">            for (final Iterator&lt;V&gt; it = iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L1211">                final V value = it.next();</span>
<span class="fc bfc" id="L1212" title="All 2 branches covered.">                if (compare(value, o)) {</span>
<span class="fc" id="L1213">                    it.remove();</span>
<span class="fc" id="L1214">                    return true;</span>
                }
<span class="fc" id="L1216">            }</span>
<span class="nc" id="L1217">            return false;</span>
        }

        @Override
        public int size() {
<span class="fc" id="L1222">            return AbstractPatriciaTrie.this.size();</span>
        }
    }

    private static final long serialVersionUID = 5155253417231339498L;

    /**
     * Returns true if 'next' is a valid uplink coming from 'from'.
     */
    static boolean isValidUplink(final TrieEntry&lt;?, ?&gt; next, final TrieEntry&lt;?, ?&gt; from) {
<span class="pc bpc" id="L1232" title="1 of 6 branches missed.">        return next != null &amp;&amp; next.bitIndex &lt;= from.bitIndex &amp;&amp; !next.isEmpty();</span>
    }

    /** The root node of the {@link org.apache.commons.collections4.Trie}. */
<span class="pc" id="L1236">    private transient TrieEntry&lt;K, V&gt; root = new TrieEntry&lt;&gt;(null, null, -1);</span>

    /**
     * Each of these fields are initialized to contain an instance of the
     * appropriate view the first time this view is requested. The views are
     * stateless, so there's no reason to create more than one of each.
     */
    private transient volatile Set&lt;K&gt; keySet;

    private transient volatile Collection&lt;V&gt; values;

    private transient volatile Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;

    /** The current size of the {@link org.apache.commons.collections4.Trie}. */
    private transient int size;

    /**
     * The number of times this {@link org.apache.commons.collections4.Trie} has been modified.
     * It's used to detect concurrent modifications and fail-fast the {@link Iterator}s.
     */
    protected transient int modCount;

    /**
     * Constructs a new {@link Trie} using the given {@link KeyAnalyzer}.
     *
     * @param keyAnalyzer  the {@link KeyAnalyzer}.
     */
    protected AbstractPatriciaTrie(final KeyAnalyzer&lt;? super K&gt; keyAnalyzer) {
<span class="fc" id="L1264">        super(keyAnalyzer);</span>
<span class="fc" id="L1265">    }</span>

    /**
     * Constructs a new {@link org.apache.commons.collections4.Trie} using the given {@link KeyAnalyzer} and initializes the
     * {@link org.apache.commons.collections4.Trie} with the values from the provided {@link Map}.
     *
     * @param keyAnalyzer  the {@link KeyAnalyzer}.
     * @param map The source map.
     */
    protected AbstractPatriciaTrie(final KeyAnalyzer&lt;? super K&gt; keyAnalyzer, final Map&lt;? extends K, ? extends V&gt; map) {
<span class="nc" id="L1275">        super(keyAnalyzer);</span>
<span class="nc" id="L1276">        putAll(map);</span>
<span class="nc" id="L1277">    }</span>

    /**
     * Adds the given {@link TrieEntry} to the {@link org.apache.commons.collections4.Trie}.
     */
    TrieEntry&lt;K, V&gt; addEntry(final TrieEntry&lt;K, V&gt; entry, final int lengthInBits) {
<span class="fc" id="L1283">        TrieEntry&lt;K, V&gt; current = root.left;</span>
<span class="fc" id="L1284">        TrieEntry&lt;K, V&gt; path = root;</span>
        while (true) {
<span class="fc bfc" id="L1286" title="All 4 branches covered.">            if (current.bitIndex &gt;= entry.bitIndex</span>
                    || current.bitIndex &lt;= path.bitIndex) {
<span class="fc" id="L1288">                entry.predecessor = entry;</span>

<span class="fc bfc" id="L1290" title="All 2 branches covered.">                if (!isBitSet(entry.key, entry.bitIndex, lengthInBits)) {</span>
<span class="fc" id="L1291">                    entry.left = entry;</span>
<span class="fc" id="L1292">                    entry.right = current;</span>
                } else {
<span class="fc" id="L1294">                    entry.left = current;</span>
<span class="fc" id="L1295">                    entry.right = entry;</span>
                }

<span class="fc" id="L1298">                entry.parent = path;</span>
<span class="fc bfc" id="L1299" title="All 2 branches covered.">                if (current.bitIndex &gt;= entry.bitIndex) {</span>
<span class="fc" id="L1300">                    current.parent = entry;</span>
                }

                // if we inserted an uplink, set the predecessor on it
<span class="fc bfc" id="L1304" title="All 2 branches covered.">                if (current.bitIndex &lt;= path.bitIndex) {</span>
<span class="fc" id="L1305">                    current.predecessor = entry;</span>
                }

<span class="fc bfc" id="L1308" title="All 4 branches covered.">                if (path == root || !isBitSet(entry.key, path.bitIndex, lengthInBits)) {</span>
<span class="fc" id="L1309">                    path.left = entry;</span>
                } else {
<span class="fc" id="L1311">                    path.right = entry;</span>
                }

<span class="fc" id="L1314">                return entry;</span>
            }

<span class="fc" id="L1317">            path = current;</span>

<span class="fc bfc" id="L1319" title="All 2 branches covered.">            if (!isBitSet(entry.key, current.bitIndex, lengthInBits)) {</span>
<span class="fc" id="L1320">                current = current.left;</span>
            } else {
<span class="fc" id="L1322">                current = current.right;</span>
            }
        }
    }

    /**
     * Returns a key-value mapping associated with the least key greater
     * than or equal to the given key, or null if there is no such key.
     */
    TrieEntry&lt;K, V&gt; ceilingEntry(final K key) {
        // Basically:
        // Follow the steps of adding an entry, but instead...
        //
        // - If we ever encounter a situation where we found an equal
        //   key, we return it immediately.
        //
        // - If we hit an empty root, return the first iterable item.
        //
        // - If we have to add a new item, we temporarily add it,
        //   find the successor to it, then remove the added item.
        //
        // These steps ensure that the returned value is either the
        // entry for the key itself, or the first entry directly after
        // the key.

        // TODO: Cleanup so that we don't actually have to add/remove from the
        //       tree.  (We do it here because there are other well-defined
        //       functions to perform the search.)
<span class="nc" id="L1350">        final int lengthInBits = lengthInBits(key);</span>

<span class="nc bnc" id="L1352" title="All 2 branches missed.">        if (lengthInBits == 0) {</span>
<span class="nc bnc" id="L1353" title="All 2 branches missed.">            if (!root.isEmpty()) {</span>
<span class="nc" id="L1354">                return root;</span>
            }
<span class="nc" id="L1356">            return firstEntry();</span>
        }

<span class="nc" id="L1359">        final TrieEntry&lt;K, V&gt; found = getNearestEntryForKey(key, lengthInBits);</span>
<span class="nc bnc" id="L1360" title="All 2 branches missed.">        if (compareKeys(key, found.key)) {</span>
<span class="nc" id="L1361">            return found;</span>
        }

<span class="nc" id="L1364">        final int bitIndex = bitIndex(key, found.key);</span>
<span class="nc bnc" id="L1365" title="All 2 branches missed.">        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {</span>
<span class="nc" id="L1366">            final TrieEntry&lt;K, V&gt; added = new TrieEntry&lt;&gt;(key, null, bitIndex);</span>
<span class="nc" id="L1367">            addEntry(added, lengthInBits);</span>
<span class="nc" id="L1368">            incrementSize(); // must increment because remove will decrement</span>
<span class="nc" id="L1369">            final TrieEntry&lt;K, V&gt; ceil = nextEntry(added);</span>
<span class="nc" id="L1370">            removeEntry(added);</span>
<span class="nc" id="L1371">            modCount -= 2; // we didn't really modify it.</span>
<span class="nc" id="L1372">            return ceil;</span>
        }
<span class="nc bnc" id="L1374" title="All 2 branches missed.">        if (KeyAnalyzer.isNullBitKey(bitIndex)) {</span>
<span class="nc bnc" id="L1375" title="All 2 branches missed.">            if (!root.isEmpty()) {</span>
<span class="nc" id="L1376">                return root;</span>
            }
<span class="nc" id="L1378">            return firstEntry();</span>
        }
<span class="nc bnc" id="L1380" title="All 2 branches missed.">        if (KeyAnalyzer.isEqualBitKey(bitIndex)) {</span>
<span class="nc" id="L1381">            return found;</span>
        }

        // we should have exited above.
<span class="nc" id="L1385">        throw new IllegalStateException(&quot;invalid lookup: &quot; + key);</span>
    }

    @Override
    public void clear() {
<span class="fc" id="L1390">        root.key = null;</span>
<span class="fc" id="L1391">        root.bitIndex = -1;</span>
<span class="fc" id="L1392">        root.value = null;</span>

<span class="fc" id="L1394">        root.parent = null;</span>
<span class="fc" id="L1395">        root.left = root;</span>
<span class="fc" id="L1396">        root.right = null;</span>
<span class="fc" id="L1397">        root.predecessor = root;</span>

<span class="fc" id="L1399">        size = 0;</span>
<span class="fc" id="L1400">        incrementModCount();</span>
<span class="fc" id="L1401">    }</span>

    @Override
    public Comparator&lt;? super K&gt; comparator() {
<span class="fc" id="L1405">        return getKeyAnalyzer();</span>
    }

    @Override
    public boolean containsKey(final Object k) {
<span class="pc bpc" id="L1410" title="1 of 2 branches missed.">        if (k == null) {</span>
<span class="nc" id="L1411">            return false;</span>
        }

<span class="fc" id="L1414">        final K key = castKey(k);</span>
<span class="fc" id="L1415">        final int lengthInBits = lengthInBits(key);</span>
<span class="fc" id="L1416">        final TrieEntry&lt;K, V&gt; entry = getNearestEntryForKey(key, lengthInBits);</span>
<span class="fc bfc" id="L1417" title="All 4 branches covered.">        return !entry.isEmpty() &amp;&amp; compareKeys(key, entry.key);</span>
    }

    /**
     * A helper method to decrement the {@link org.apache.commons.collections4.Trie} size and increment the modification counter.
     */
    void decrementSize() {
<span class="fc" id="L1424">        size--;</span>
<span class="fc" id="L1425">        incrementModCount();</span>
<span class="fc" id="L1426">    }</span>

    @Override
    public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() {
<span class="fc bfc" id="L1430" title="All 2 branches covered.">        if (entrySet == null) {</span>
<span class="fc" id="L1431">            entrySet = new EntrySet();</span>
        }
<span class="fc" id="L1433">        return entrySet;</span>
    }

    /**
     * Returns the first entry the {@link org.apache.commons.collections4.Trie} is storing.
     * &lt;p&gt;
     * This is implemented by going always to the left until
     * we encounter a valid uplink. That uplink is the first key.
     */
    TrieEntry&lt;K, V&gt; firstEntry() {
        // if Trie is empty, no first node.
<span class="fc bfc" id="L1444" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L1445">            return null;</span>
        }

<span class="fc" id="L1448">        return followLeft(root);</span>
    }

    @Override
    public K firstKey() {
<span class="fc bfc" id="L1453" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L1454">            throw new NoSuchElementException();</span>
        }
<span class="fc" id="L1456">        return firstEntry().getKey();</span>
    }

    /**
     * Returns a key-value mapping associated with the greatest key
     * less than or equal to the given key, or null if there is no such key.
     */
    TrieEntry&lt;K, V&gt; floorEntry(final K key) {
        // TODO: Cleanup so that we don't actually have to add/remove from the
        //       tree.  (We do it here because there are other well-defined
        //       functions to perform the search.)
<span class="nc" id="L1467">        final int lengthInBits = lengthInBits(key);</span>

<span class="nc bnc" id="L1469" title="All 2 branches missed.">        if (lengthInBits == 0) {</span>
<span class="nc bnc" id="L1470" title="All 2 branches missed.">            if (!root.isEmpty()) {</span>
<span class="nc" id="L1471">                return root;</span>
            }
<span class="nc" id="L1473">            return null;</span>
        }

<span class="nc" id="L1476">        final TrieEntry&lt;K, V&gt; found = getNearestEntryForKey(key, lengthInBits);</span>
<span class="nc bnc" id="L1477" title="All 2 branches missed.">        if (compareKeys(key, found.key)) {</span>
<span class="nc" id="L1478">            return found;</span>
        }

<span class="nc" id="L1481">        final int bitIndex = bitIndex(key, found.key);</span>
<span class="nc bnc" id="L1482" title="All 2 branches missed.">        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {</span>
<span class="nc" id="L1483">            final TrieEntry&lt;K, V&gt; added = new TrieEntry&lt;&gt;(key, null, bitIndex);</span>
<span class="nc" id="L1484">            addEntry(added, lengthInBits);</span>
<span class="nc" id="L1485">            incrementSize(); // must increment because remove will decrement</span>
<span class="nc" id="L1486">            final TrieEntry&lt;K, V&gt; floor = previousEntry(added);</span>
<span class="nc" id="L1487">            removeEntry(added);</span>
<span class="nc" id="L1488">            modCount -= 2; // we didn't really modify it.</span>
<span class="nc" id="L1489">            return floor;</span>
        }
<span class="nc bnc" id="L1491" title="All 2 branches missed.">        if (KeyAnalyzer.isNullBitKey(bitIndex)) {</span>
<span class="nc bnc" id="L1492" title="All 2 branches missed.">            if (!root.isEmpty()) {</span>
<span class="nc" id="L1493">                return root;</span>
            }
<span class="nc" id="L1495">            return null;</span>
        }
<span class="nc bnc" id="L1497" title="All 2 branches missed.">        if (KeyAnalyzer.isEqualBitKey(bitIndex)) {</span>
<span class="nc" id="L1498">            return found;</span>
        }

        // we should have exited above.
<span class="nc" id="L1502">        throw new IllegalStateException(&quot;invalid lookup: &quot; + key);</span>
    }

    /**
     * Goes left through the tree until it finds a valid node.
     */
    TrieEntry&lt;K, V&gt; followLeft(TrieEntry&lt;K, V&gt; node) {
        while (true) {
<span class="fc" id="L1510">            TrieEntry&lt;K, V&gt; child = node.left;</span>
            // if we hit root and it didn't have a node, go right instead.
<span class="fc bfc" id="L1512" title="All 2 branches covered.">            if (child.isEmpty()) {</span>
<span class="fc" id="L1513">                child = node.right;</span>
            }

<span class="fc bfc" id="L1516" title="All 2 branches covered.">            if (child.bitIndex &lt;= node.bitIndex) {</span>
<span class="fc" id="L1517">                return child;</span>
            }

<span class="fc" id="L1520">            node = child;</span>
<span class="fc" id="L1521">        }</span>
    }

    /**
     * Traverses down the right path until it finds an uplink.
     */
    TrieEntry&lt;K, V&gt; followRight(TrieEntry&lt;K, V&gt; node) {
        // if Trie is empty, no last entry.
<span class="fc bfc" id="L1529" title="All 2 branches covered.">        if (node.right == null) {</span>
<span class="fc" id="L1530">            return null;</span>
        }

        // Go as far right as possible, until we encounter an uplink.
<span class="fc bfc" id="L1534" title="All 2 branches covered.">        while (node.right.bitIndex &gt; node.bitIndex) {</span>
<span class="fc" id="L1535">            node = node.right;</span>
        }

<span class="fc" id="L1538">        return node.right;</span>
    }

    @Override
    public V get(final Object k) {
<span class="fc" id="L1543">        final TrieEntry&lt;K, V&gt; entry = getEntry(k);</span>
<span class="fc bfc" id="L1544" title="All 2 branches covered.">        return entry != null ? entry.getValue() : null;</span>
    }

    /**
     * Gets the entry associated with the specified key in the
     * PatriciaTrieBase.  Returns null if the map contains no mapping
     * for this key.
     * &lt;p&gt;
     * This may throw ClassCastException if the object is not of type K.
     */
    TrieEntry&lt;K, V&gt; getEntry(final Object k) {
<span class="fc" id="L1555">        final K key = castKey(k);</span>
<span class="pc bpc" id="L1556" title="1 of 2 branches missed.">        if (key == null) {</span>
<span class="nc" id="L1557">            return null;</span>
        }

<span class="fc" id="L1560">        final int lengthInBits = lengthInBits(key);</span>
<span class="fc" id="L1561">        final TrieEntry&lt;K, V&gt; entry = getNearestEntryForKey(key, lengthInBits);</span>
<span class="fc bfc" id="L1562" title="All 4 branches covered.">        return !entry.isEmpty() &amp;&amp; compareKeys(key, entry.key) ? entry : null;</span>
    }

    /**
     * Gets the nearest entry for a given key.  This is useful
     * for finding knowing if a given key exists (and finding the value
     * for it), or for inserting the key.
     *
     * The actual get implementation. This is very similar to
     * selectR but with the exception that it might return the
     * root Entry even if it's empty.
     */
    TrieEntry&lt;K, V&gt; getNearestEntryForKey(final K key, final int lengthInBits) {
<span class="fc" id="L1575">        TrieEntry&lt;K, V&gt; current = root.left;</span>
<span class="fc" id="L1576">        TrieEntry&lt;K, V&gt; path = root;</span>
        while (true) {
<span class="fc bfc" id="L1578" title="All 2 branches covered.">            if (current.bitIndex &lt;= path.bitIndex) {</span>
<span class="fc" id="L1579">                return current;</span>
            }

<span class="fc" id="L1582">            path = current;</span>
<span class="fc bfc" id="L1583" title="All 2 branches covered.">            if (!isBitSet(key, current.bitIndex, lengthInBits)) {</span>
<span class="fc" id="L1584">                current = current.left;</span>
            } else {
<span class="fc" id="L1586">                current = current.right;</span>
            }
        }
    }

    /**
     * Gets a view of this {@link org.apache.commons.collections4.Trie} of all elements that are prefixed
     * by the number of bits in the given Key.
     * &lt;p&gt;
     * The view that this returns is optimized to have a very efficient
     * {@link Iterator}. The {@link SortedMap#firstKey()},
     * {@link SortedMap#lastKey()} &amp;amp; {@link Map#size()} methods must
     * iterate over all possible values in order to determine the results.
     * This information is cached until the PATRICIA {@link org.apache.commons.collections4.Trie} changes.
     * All other methods (except {@link Iterator}) must compare the given
     * key to the prefix to ensure that it is within the range of the view.
     * The {@link Iterator}'s remove method must also relocate the subtree
     * that contains the prefixes if the entry holding the subtree is
     * removed or changes. Changing the subtree takes O(K) time.
     *
     * @param key  the key to use in the search
     * @param offsetInBits  the prefix offset
     * @param lengthInBits  the number of significant prefix bits
     * @return a {@link SortedMap} view of this {@link org.apache.commons.collections4.Trie} with all elements whose
     *   key is prefixed by the search key
     */
    private SortedMap&lt;K, V&gt; getPrefixMapByBits(final K key, final int offsetInBits, final int lengthInBits) {

<span class="fc" id="L1614">        final int offsetLength = offsetInBits + lengthInBits;</span>
<span class="pc bpc" id="L1615" title="1 of 2 branches missed.">        if (offsetLength &gt; lengthInBits(key)) {</span>
<span class="nc" id="L1616">            throw new IllegalArgumentException(offsetInBits + &quot; + &quot;</span>
<span class="nc" id="L1617">                    + lengthInBits + &quot; &gt; &quot; + lengthInBits(key));</span>
        }

<span class="fc bfc" id="L1620" title="All 2 branches covered.">        if (offsetLength == 0) {</span>
<span class="fc" id="L1621">            return this;</span>
        }

<span class="fc" id="L1624">        return new PrefixRangeMap(key, offsetInBits, lengthInBits);</span>
    }

    @Override
    public SortedMap&lt;K, V&gt; headMap(final K toKey) {
<span class="nc" id="L1629">        return new RangeEntryMap(null, toKey);</span>
    }

    /**
     * Returns an entry strictly higher than the given key,
     * or null if no such entry exists.
     */
    TrieEntry&lt;K, V&gt; higherEntry(final K key) {
        // TODO: Cleanup so that we don't actually have to add/remove from the
        //       tree.  (We do it here because there are other well-defined
        //       functions to perform the search.)
<span class="fc" id="L1640">        final int lengthInBits = lengthInBits(key);</span>

<span class="fc bfc" id="L1642" title="All 2 branches covered.">        if (lengthInBits == 0) {</span>
<span class="pc bpc" id="L1643" title="1 of 2 branches missed.">            if (!root.isEmpty()) {</span>
                // If data in root, and more after -- return it.
<span class="pc bpc" id="L1645" title="1 of 2 branches missed.">                if (size() &gt; 1) {</span>
<span class="fc" id="L1646">                    return nextEntry(root);</span>
                }
                // If no more after, no higher entry.
<span class="nc" id="L1649">                return null;</span>
            }
            // Root is empty &amp; we want something after empty, return first.
<span class="nc" id="L1652">            return firstEntry();</span>
        }

<span class="fc" id="L1655">        final TrieEntry&lt;K, V&gt; found = getNearestEntryForKey(key, lengthInBits);</span>
<span class="pc bpc" id="L1656" title="1 of 2 branches missed.">        if (compareKeys(key, found.key)) {</span>
<span class="fc" id="L1657">            return nextEntry(found);</span>
        }

<span class="nc" id="L1660">        final int bitIndex = bitIndex(key, found.key);</span>
<span class="nc bnc" id="L1661" title="All 2 branches missed.">        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {</span>
<span class="nc" id="L1662">            final TrieEntry&lt;K, V&gt; added = new TrieEntry&lt;&gt;(key, null, bitIndex);</span>
<span class="nc" id="L1663">            addEntry(added, lengthInBits);</span>
<span class="nc" id="L1664">            incrementSize(); // must increment because remove will decrement</span>
<span class="nc" id="L1665">            final TrieEntry&lt;K, V&gt; ceil = nextEntry(added);</span>
<span class="nc" id="L1666">            removeEntry(added);</span>
<span class="nc" id="L1667">            modCount -= 2; // we didn't really modify it.</span>
<span class="nc" id="L1668">            return ceil;</span>
        }
<span class="nc bnc" id="L1670" title="All 2 branches missed.">        if (KeyAnalyzer.isNullBitKey(bitIndex)) {</span>
<span class="nc bnc" id="L1671" title="All 2 branches missed.">            if (!root.isEmpty()) {</span>
<span class="nc" id="L1672">                return firstEntry();</span>
            }
<span class="nc bnc" id="L1674" title="All 2 branches missed.">            if (size() &gt; 1) {</span>
<span class="nc" id="L1675">                return nextEntry(firstEntry());</span>
            }
<span class="nc" id="L1677">            return null;</span>
        }
<span class="nc bnc" id="L1679" title="All 2 branches missed.">        if (KeyAnalyzer.isEqualBitKey(bitIndex)) {</span>
<span class="nc" id="L1680">            return nextEntry(found);</span>
        }

        // we should have exited above.
<span class="nc" id="L1684">        throw new IllegalStateException(&quot;invalid lookup: &quot; + key);</span>
    }

    /**
     * A helper method to increment the modification counter.
     */
    private void incrementModCount() {
<span class="fc" id="L1691">        ++modCount;</span>
<span class="fc" id="L1692">    }</span>

    /**
     * A helper method to increment the {@link org.apache.commons.collections4.Trie} size and the modification counter.
     */
    void incrementSize() {
<span class="fc" id="L1698">        size++;</span>
<span class="fc" id="L1699">        incrementModCount();</span>
<span class="fc" id="L1700">    }</span>

    @Override
    public Set&lt;K&gt; keySet() {
<span class="fc bfc" id="L1704" title="All 2 branches covered.">        if (keySet == null) {</span>
<span class="fc" id="L1705">            keySet = new KeySet();</span>
        }
<span class="fc" id="L1707">        return keySet;</span>
    }

    /**
     * Returns the last entry the {@link org.apache.commons.collections4.Trie} is storing.
     *
     * &lt;p&gt;This is implemented by going always to the right until
     * we encounter a valid uplink. That uplink is the last key.
     */
    TrieEntry&lt;K, V&gt; lastEntry() {
<span class="fc" id="L1717">        return followRight(root.left);</span>
    }

    @Override
    public K lastKey() {
<span class="fc" id="L1722">        final TrieEntry&lt;K, V&gt; entry = lastEntry();</span>
<span class="fc bfc" id="L1723" title="All 2 branches covered.">        if (entry != null) {</span>
<span class="fc" id="L1724">            return entry.getKey();</span>
        }
<span class="fc" id="L1726">        throw new NoSuchElementException();</span>
    }

    /**
     * Returns a key-value mapping associated with the greatest key
     * strictly less than the given key, or null if there is no such key.
     */
    TrieEntry&lt;K, V&gt; lowerEntry(final K key) {
        // Basically:
        // Follow the steps of adding an entry, but instead...
        //
        // - If we ever encounter a situation where we found an equal
        //   key, we return it's previousEntry immediately.
        //
        // - If we hit root (empty or not), return null.
        //
        // - If we have to add a new item, we temporarily add it,
        //   find the previousEntry to it, then remove the added item.
        //
        // These steps ensure that the returned value is always just before
        // the key or null (if there was nothing before it).

        // TODO: Cleanup so that we don't actually have to add/remove from the
        //       tree.  (We do it here because there are other well-defined
        //       functions to perform the search.)
<span class="fc" id="L1751">        final int lengthInBits = lengthInBits(key);</span>

<span class="pc bpc" id="L1753" title="1 of 2 branches missed.">        if (lengthInBits == 0) {</span>
<span class="nc" id="L1754">            return null; // there can never be anything before root.</span>
        }

<span class="fc" id="L1757">        final TrieEntry&lt;K, V&gt; found = getNearestEntryForKey(key, lengthInBits);</span>
<span class="pc bpc" id="L1758" title="1 of 2 branches missed.">        if (compareKeys(key, found.key)) {</span>
<span class="fc" id="L1759">            return previousEntry(found);</span>
        }

<span class="nc" id="L1762">        final int bitIndex = bitIndex(key, found.key);</span>
<span class="nc bnc" id="L1763" title="All 2 branches missed.">        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {</span>
<span class="nc" id="L1764">            final TrieEntry&lt;K, V&gt; added = new TrieEntry&lt;&gt;(key, null, bitIndex);</span>
<span class="nc" id="L1765">            addEntry(added, lengthInBits);</span>
<span class="nc" id="L1766">            incrementSize(); // must increment because remove will decrement</span>
<span class="nc" id="L1767">            final TrieEntry&lt;K, V&gt; prior = previousEntry(added);</span>
<span class="nc" id="L1768">            removeEntry(added);</span>
<span class="nc" id="L1769">            modCount -= 2; // we didn't really modify it.</span>
<span class="nc" id="L1770">            return prior;</span>
        }
<span class="nc bnc" id="L1772" title="All 2 branches missed.">        if (KeyAnalyzer.isNullBitKey(bitIndex)) {</span>
<span class="nc" id="L1773">            return null;</span>
        }
<span class="nc bnc" id="L1775" title="All 2 branches missed.">        if (KeyAnalyzer.isEqualBitKey(bitIndex)) {</span>
<span class="nc" id="L1776">            return previousEntry(found);</span>
        }

        // we should have exited above.
<span class="nc" id="L1780">        throw new IllegalStateException(&quot;invalid lookup: &quot; + key);</span>
    }

    @Override
    public OrderedMapIterator&lt;K, V&gt; mapIterator() {
<span class="nc" id="L1785">        return new TrieMapIterator();</span>
    }

    /**
     * Returns the entry lexicographically after the given entry.
     * If the given entry is null, returns the first node.
     */
    TrieEntry&lt;K, V&gt; nextEntry(final TrieEntry&lt;K, V&gt; node) {
<span class="fc bfc" id="L1793" title="All 2 branches covered.">        if (node == null) {</span>
<span class="fc" id="L1794">            return firstEntry();</span>
        }
<span class="fc" id="L1796">        return nextEntryImpl(node.predecessor, node, null);</span>
    }

    /**
     * Scans for the next node, starting at the specified point, and using 'previous'
     * as a hint that the last node we returned was 'previous' (so we know not to return
     * it again).  If 'tree' is non-null, this will limit the search to the given tree.
     *
     * The basic premise is that each iteration can follow the following steps:
     *
     * 1) Scan all the way to the left.
     *   a) If we already started from this node last time, proceed to Step 2.
     *   b) If a valid uplink is found, use it.
     *   c) If the result is an empty node (root not set), break the scan.
     *   d) If we already returned the left node, break the scan.
     *
     * 2) Check the right.
     *   a) If we already returned the right node, proceed to Step 3.
     *   b) If it is a valid uplink, use it.
     *   c) Do Step 1 from the right node.
     *
     * 3) Back up through the parents until we encounter find a parent
     *    that we're not the right child of.
     *
     * 4) If there's no right child of that parent, the iteration is finished.
     *    Otherwise continue to Step 5.
     *
     * 5) Check to see if the right child is a valid uplink.
     *    a) If we already returned that child, proceed to Step 6.
     *       Otherwise, use it.
     *
     * 6) If the right child of the parent is the parent itself, we've
     *    already found &amp;amp; returned the end of the Trie, so exit.
     *
     * 7) Do Step 1 on the parent's right child.
     */
    TrieEntry&lt;K, V&gt; nextEntryImpl(final TrieEntry&lt;K, V&gt; start,
            final TrieEntry&lt;K, V&gt; previous, final TrieEntry&lt;K, V&gt; tree) {

<span class="fc" id="L1835">        TrieEntry&lt;K, V&gt; current = start;</span>

        // Only look at the left if this was a recursive or
        // the first check, otherwise we know we've already looked
        // at the left.
<span class="pc bpc" id="L1840" title="1 of 4 branches missed.">        if (previous == null || start != previous.predecessor) {</span>
<span class="pc bpc" id="L1841" title="1 of 2 branches missed.">            while (!current.left.isEmpty()) {</span>
                // stop traversing if we've already
                // returned the left of this node.
<span class="pc bpc" id="L1844" title="1 of 2 branches missed.">                if (previous == current.left) {</span>
<span class="nc" id="L1845">                    break;</span>
                }

<span class="fc bfc" id="L1848" title="All 2 branches covered.">                if (isValidUplink(current.left, current)) {</span>
<span class="fc" id="L1849">                    return current.left;</span>
                }

<span class="fc" id="L1852">                current = current.left;</span>
            }
        }

        // If there's no data at all, exit.
<span class="pc bpc" id="L1857" title="1 of 2 branches missed.">        if (current.isEmpty()) {</span>
<span class="nc" id="L1858">            return null;</span>
        }

        // If we've already returned the left,
        // and the immediate right is null,
        // there's only one entry in the Trie
        // which is stored at the root.
        //
        //  / (&quot;&quot;)   &lt;-- root
        //  \_/  \
        //       null &lt;-- 'current'
        //
<span class="pc bpc" id="L1870" title="1 of 2 branches missed.">        if (current.right == null) {</span>
<span class="nc" id="L1871">            return null;</span>
        }

        // If nothing valid on the left, try the right.
<span class="fc bfc" id="L1875" title="All 2 branches covered.">        if (previous != current.right) {</span>
            // See if it immediately is valid.
<span class="fc bfc" id="L1877" title="All 2 branches covered.">            if (isValidUplink(current.right, current)) {</span>
<span class="fc" id="L1878">                return current.right;</span>
            }

            // Must search on the right's side if it wasn't initially valid.
<span class="fc" id="L1882">            return nextEntryImpl(current.right, previous, tree);</span>
        }

        // Neither left nor right are valid, find the first parent
        // whose child did not come from the right &amp; traverse it.
<span class="fc bfc" id="L1887" title="All 2 branches covered.">        while (current == current.parent.right) {</span>
            // If we're going to traverse to above the subtree, stop.
<span class="fc bfc" id="L1889" title="All 2 branches covered.">            if (current == tree) {</span>
<span class="fc" id="L1890">                return null;</span>
            }

<span class="fc" id="L1893">            current = current.parent;</span>
        }

        // If we're on the top of the subtree, we can't go any higher.
<span class="fc bfc" id="L1897" title="All 2 branches covered.">        if (current == tree) {</span>
<span class="fc" id="L1898">            return null;</span>
        }

        // If there's no right, the parent must be root, so we're done.
<span class="fc bfc" id="L1902" title="All 2 branches covered.">        if (current.parent.right == null) {</span>
<span class="fc" id="L1903">            return null;</span>
        }

        // If the parent's right points to itself, we've found one.
<span class="pc bpc" id="L1907" title="1 of 2 branches missed.">        if (previous != current.parent.right</span>
<span class="fc bfc" id="L1908" title="All 2 branches covered.">                &amp;&amp; isValidUplink(current.parent.right, current.parent)) {</span>
<span class="fc" id="L1909">            return current.parent.right;</span>
        }

        // If the parent's right is itself, there can't be any more nodes.
<span class="pc bpc" id="L1913" title="1 of 2 branches missed.">        if (current.parent.right == current.parent) {</span>
<span class="nc" id="L1914">            return null;</span>
        }

        // We need to traverse down the parent's right's path.
<span class="fc" id="L1918">        return nextEntryImpl(current.parent.right, previous, tree);</span>
    }

    /**
     * Returns the entry lexicographically after the given entry.
     * If the given entry is null, returns the first node.
     *
     * This will traverse only within the subtree.  If the given node
     * is not within the subtree, this will have undefined results.
     */
    TrieEntry&lt;K, V&gt; nextEntryInSubtree(final TrieEntry&lt;K, V&gt; node,
            final TrieEntry&lt;K, V&gt; parentOfSubtree) {
<span class="pc bpc" id="L1930" title="1 of 2 branches missed.">        if (node == null) {</span>
<span class="nc" id="L1931">            return firstEntry();</span>
        }
<span class="fc" id="L1933">        return nextEntryImpl(node.predecessor, node, parentOfSubtree);</span>
    }

    @Override
    public K nextKey(final K key) {
<span class="fc" id="L1938">        Objects.requireNonNull(key, &quot;key&quot;);</span>
<span class="fc" id="L1939">        final TrieEntry&lt;K, V&gt; entry = getEntry(key);</span>
<span class="fc bfc" id="L1940" title="All 2 branches covered.">        if (entry != null) {</span>
<span class="fc" id="L1941">            final TrieEntry&lt;K, V&gt; nextEntry = nextEntry(entry);</span>
<span class="fc bfc" id="L1942" title="All 2 branches covered.">            return nextEntry != null ? nextEntry.getKey() : null;</span>
        }
<span class="fc" id="L1944">        return null;</span>
    }

    @Override
    public SortedMap&lt;K, V&gt; prefixMap(final K key) {
<span class="fc" id="L1949">        return getPrefixMapByBits(key, 0, lengthInBits(key));</span>
    }

    /**
     * Returns the node lexicographically before the given node (or null if none).
     *
     * This follows four simple branches:
     *  - If the uplink that returned us was a right uplink:
     *      - If predecessor's left is a valid uplink from predecessor, return it.
     *      - Else, follow the right path from the predecessor's left.
     *  - If the uplink that returned us was a left uplink:
     *      - Loop back through parents until we encounter a node where
     *        node != node.parent.left.
     *          - If node.parent.left is uplink from node.parent:
     *              - If node.parent.left is not root, return it.
     *              - If it is root &amp;amp; root isEmpty, return null.
     *              - If it is root &amp;amp; root !isEmpty, return root.
     *          - If node.parent.left is not uplink from node.parent:
     *              - Follow right path for first right child from node.parent.left
     *
     * @param start  the start entry
     */
    TrieEntry&lt;K, V&gt; previousEntry(final TrieEntry&lt;K, V&gt; start) {
<span class="pc bpc" id="L1972" title="1 of 2 branches missed.">        if (start.predecessor == null) {</span>
<span class="nc" id="L1973">            throw new IllegalArgumentException(&quot;must have come from somewhere!&quot;);</span>
        }

<span class="fc bfc" id="L1976" title="All 2 branches covered.">        if (start.predecessor.right == start) {</span>
<span class="fc bfc" id="L1977" title="All 2 branches covered.">            if (isValidUplink(start.predecessor.left, start.predecessor)) {</span>
<span class="fc" id="L1978">                return start.predecessor.left;</span>
            }
<span class="fc" id="L1980">            return followRight(start.predecessor.left);</span>
        }
<span class="fc" id="L1982">        TrieEntry&lt;K, V&gt; node = start.predecessor;</span>
<span class="pc bpc" id="L1983" title="1 of 4 branches missed.">        while (node.parent != null &amp;&amp; node == node.parent.left) {</span>
<span class="fc" id="L1984">            node = node.parent;</span>
        }

<span class="pc bpc" id="L1987" title="1 of 2 branches missed.">        if (node.parent == null) { // can be null if we're looking up root.</span>
<span class="nc" id="L1988">            return null;</span>
        }

<span class="fc bfc" id="L1991" title="All 2 branches covered.">        if (isValidUplink(node.parent.left, node.parent)) {</span>
<span class="fc bfc" id="L1992" title="All 2 branches covered.">            if (node.parent.left == root) {</span>
<span class="pc bpc" id="L1993" title="1 of 2 branches missed.">                if (root.isEmpty()) {</span>
<span class="nc" id="L1994">                    return null;</span>
                }
<span class="fc" id="L1996">                return root;</span>

            }
<span class="fc" id="L1999">            return node.parent.left;</span>
        }
<span class="fc" id="L2001">        return followRight(node.parent.left);</span>
    }

    @Override
    public K previousKey(final K key) {
<span class="fc" id="L2006">        Objects.requireNonNull(key, &quot;key&quot;);</span>
<span class="fc" id="L2007">        final TrieEntry&lt;K, V&gt; entry = getEntry(key);</span>
<span class="fc bfc" id="L2008" title="All 2 branches covered.">        if (entry != null) {</span>
<span class="fc" id="L2009">            final TrieEntry&lt;K, V&gt; prevEntry = previousEntry(entry);</span>
<span class="fc bfc" id="L2010" title="All 2 branches covered.">            return prevEntry != null ? prevEntry.getKey() : null;</span>
        }
<span class="fc" id="L2012">        return null;</span>
    }

    @Override
    public V put(final K key, final V value) {
<span class="fc" id="L2017">        Objects.requireNonNull(key, &quot;key&quot;);</span>

<span class="fc" id="L2019">        final int lengthInBits = lengthInBits(key);</span>

        // The only place to store a key with a length
        // of zero bits is the root node
<span class="fc bfc" id="L2023" title="All 2 branches covered.">        if (lengthInBits == 0) {</span>
<span class="pc bpc" id="L2024" title="1 of 2 branches missed.">            if (root.isEmpty()) {</span>
<span class="fc" id="L2025">                incrementSize();</span>
            } else {
<span class="nc" id="L2027">                incrementModCount();</span>
            }
<span class="fc" id="L2029">            return root.setKeyValue(key, value);</span>
        }

<span class="fc" id="L2032">        final TrieEntry&lt;K, V&gt; found = getNearestEntryForKey(key, lengthInBits);</span>
<span class="fc bfc" id="L2033" title="All 2 branches covered.">        if (compareKeys(key, found.key)) {</span>
<span class="pc bpc" id="L2034" title="1 of 2 branches missed.">            if (found.isEmpty()) { // &lt;- must be the root</span>
<span class="nc" id="L2035">                incrementSize();</span>
            } else {
<span class="fc" id="L2037">                incrementModCount();</span>
            }
<span class="fc" id="L2039">            return found.setKeyValue(key, value);</span>
        }

<span class="fc" id="L2042">        final int bitIndex = bitIndex(key, found.key);</span>
<span class="pc bpc" id="L2043" title="1 of 2 branches missed.">        if (!KeyAnalyzer.isOutOfBoundsIndex(bitIndex)) {</span>
<span class="pc bpc" id="L2044" title="1 of 2 branches missed.">            if (KeyAnalyzer.isValidBitIndex(bitIndex)) { // in 99.999...9% the case</span>
                /* NEW KEY+VALUE TUPLE */
<span class="fc" id="L2046">                final TrieEntry&lt;K, V&gt; t = new TrieEntry&lt;&gt;(key, value, bitIndex);</span>
<span class="fc" id="L2047">                addEntry(t, lengthInBits);</span>
<span class="fc" id="L2048">                incrementSize();</span>
<span class="fc" id="L2049">                return null;</span>
            }
<span class="nc bnc" id="L2051" title="All 2 branches missed.">            if (KeyAnalyzer.isNullBitKey(bitIndex)) {</span>
                // A bits of the Key are zero. The only place to
                // store such a Key is the root Node!

                /* NULL BIT KEY */
<span class="nc bnc" id="L2056" title="All 2 branches missed.">                if (root.isEmpty()) {</span>
<span class="nc" id="L2057">                    incrementSize();</span>
                } else {
<span class="nc" id="L2059">                    incrementModCount();</span>
                }
<span class="nc" id="L2061">                return root.setKeyValue(key, value);</span>

            }
<span class="nc bnc" id="L2064" title="All 4 branches missed.">            if (KeyAnalyzer.isEqualBitKey(bitIndex) &amp;&amp; found != root) { // NOPMD</span>
<span class="nc" id="L2065">                incrementModCount();</span>
<span class="nc" id="L2066">                return found.setKeyValue(key, value);</span>
            }
        }

<span class="nc" id="L2070">        throw new IllegalArgumentException(&quot;Failed to put: &quot; + key + &quot; -&gt; &quot; + value + &quot;, &quot; + bitIndex);</span>
    }

    /**
     * Deserializes an instance from an ObjectInputStream.
     *
     * @param in The source ObjectInputStream.
     * @throws IOException            Any of the usual Input/Output related exceptions.
     * @throws ClassNotFoundException A class of a serialized object cannot be found.
     */
    @SuppressWarnings(&quot;unchecked&quot;) // This will fail at runtime if the stream is incorrect
    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {
<span class="fc" id="L2082">        in.defaultReadObject();</span>
<span class="fc" id="L2083">        root = new TrieEntry&lt;&gt;(null, null, -1);</span>
<span class="fc" id="L2084">        final int size = in.readInt();</span>
<span class="fc bfc" id="L2085" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L2086">            final K k = (K) in.readObject();</span>
<span class="fc" id="L2087">            final V v = (V) in.readObject();</span>
<span class="fc" id="L2088">            put(k, v);</span>
        }
<span class="fc" id="L2090">    }</span>

    /**
     * {@inheritDoc}
     *
     * @throws ClassCastException if provided key is of an incompatible type
     */
    @Override
    public V remove(final Object k) {
<span class="pc bpc" id="L2099" title="1 of 2 branches missed.">        if (k == null) {</span>
<span class="nc" id="L2100">            return null;</span>
        }

<span class="fc" id="L2103">        final K key = castKey(k);</span>
<span class="fc" id="L2104">        final int lengthInBits = lengthInBits(key);</span>
<span class="fc" id="L2105">        TrieEntry&lt;K, V&gt; current = root.left;</span>
<span class="fc" id="L2106">        TrieEntry&lt;K, V&gt; path = root;</span>
        while (true) {
<span class="fc bfc" id="L2108" title="All 2 branches covered.">            if (current.bitIndex &lt;= path.bitIndex) {</span>
<span class="fc bfc" id="L2109" title="All 4 branches covered.">                if (!current.isEmpty() &amp;&amp; compareKeys(key, current.key)) {</span>
<span class="fc" id="L2110">                    return removeEntry(current);</span>
                }
<span class="fc" id="L2112">                return null;</span>
            }

<span class="fc" id="L2115">            path = current;</span>

<span class="fc bfc" id="L2117" title="All 2 branches covered.">            if (!isBitSet(key, current.bitIndex, lengthInBits)) {</span>
<span class="fc" id="L2118">                current = current.left;</span>
            } else {
<span class="fc" id="L2120">                current = current.right;</span>
            }
        }
    }

    /**
     * Removes a single entry from the {@link org.apache.commons.collections4.Trie}.
     *
     * If we found a Key (Entry h) then figure out if it's
     * an internal (hard to remove) or external Entry (easy
     * to remove)
     */
    V removeEntry(final TrieEntry&lt;K, V&gt; h) {
<span class="pc bpc" id="L2133" title="1 of 2 branches missed.">        if (h != root) {</span>
<span class="fc bfc" id="L2134" title="All 2 branches covered.">            if (h.isInternalNode()) {</span>
<span class="fc" id="L2135">                removeInternalEntry(h);</span>
            } else {
<span class="fc" id="L2137">                removeExternalEntry(h);</span>
            }
        }

<span class="fc" id="L2141">        decrementSize();</span>
<span class="fc" id="L2142">        return h.setKeyValue(null, null);</span>
    }

    /**
     * Removes an external entry from the {@link org.apache.commons.collections4.Trie}.
     *
     * If it's an external Entry then just remove it.
     * This is very easy and straight forward.
     */
    private void removeExternalEntry(final TrieEntry&lt;K, V&gt; h) {
<span class="pc bpc" id="L2152" title="1 of 2 branches missed.">        if (h == root) {</span>
<span class="nc" id="L2153">            throw new IllegalArgumentException(&quot;Cannot delete root Entry!&quot;);</span>
        }
<span class="pc bpc" id="L2155" title="1 of 2 branches missed.">        if (!h.isExternalNode()) {</span>
<span class="nc" id="L2156">            throw new IllegalArgumentException(h + &quot; is not an external Entry!&quot;);</span>
        }

<span class="fc" id="L2159">        final TrieEntry&lt;K, V&gt; parent = h.parent;</span>
<span class="fc bfc" id="L2160" title="All 2 branches covered.">        final TrieEntry&lt;K, V&gt; child = h.left == h ? h.right : h.left;</span>

<span class="fc bfc" id="L2162" title="All 2 branches covered.">        if (parent.left == h) {</span>
<span class="fc" id="L2163">            parent.left = child;</span>
        } else {
<span class="fc" id="L2165">            parent.right = child;</span>
        }

        // either the parent is changing, or the predecessor is changing.
<span class="fc bfc" id="L2169" title="All 2 branches covered.">        if (child.bitIndex &gt; parent.bitIndex) {</span>
<span class="fc" id="L2170">            child.parent = parent;</span>
        } else {
<span class="fc" id="L2172">            child.predecessor = parent;</span>
        }

<span class="fc" id="L2175">    }</span>

    /**
     * Removes an internal entry from the {@link org.apache.commons.collections4.Trie}.
     *
     * If it's an internal Entry then &quot;good luck&quot; with understanding
     * this code. The Idea is essentially that Entry p takes Entry h's
     * place in the trie which requires some re-wiring.
     */
    private void removeInternalEntry(final TrieEntry&lt;K, V&gt; h) {
<span class="pc bpc" id="L2185" title="1 of 2 branches missed.">        if (h == root) {</span>
<span class="nc" id="L2186">            throw new IllegalArgumentException(&quot;Cannot delete root Entry!&quot;);</span>
        }
<span class="pc bpc" id="L2188" title="1 of 2 branches missed.">        if (!h.isInternalNode()) {</span>
<span class="nc" id="L2189">            throw new IllegalArgumentException(h + &quot; is not an internal Entry!&quot;);</span>
        }

<span class="fc" id="L2192">        final TrieEntry&lt;K, V&gt; p = h.predecessor;</span>

        // Set P's bitIndex
<span class="fc" id="L2195">        p.bitIndex = h.bitIndex;</span>

        // Fix P's parent, predecessor and child Nodes
        {
<span class="fc" id="L2199">            final TrieEntry&lt;K, V&gt; parent = p.parent;</span>
<span class="fc bfc" id="L2200" title="All 2 branches covered.">            final TrieEntry&lt;K, V&gt; child = p.left == h ? p.right : p.left;</span>

            // if it was looping to itself previously,
            // it will now be pointed from its parent
            // (if we aren't removing its parent --
            //  in that case, it remains looping to itself).
            // otherwise, it will continue to have the same
            // predecessor.
<span class="fc bfc" id="L2208" title="All 4 branches covered.">            if (p.predecessor == p &amp;&amp; p.parent != h) {</span>
<span class="fc" id="L2209">                p.predecessor = p.parent;</span>
            }

<span class="fc bfc" id="L2212" title="All 2 branches covered.">            if (parent.left == p) {</span>
<span class="fc" id="L2213">                parent.left = child;</span>
            } else {
<span class="fc" id="L2215">                parent.right = child;</span>
            }

<span class="fc bfc" id="L2218" title="All 2 branches covered.">            if (child.bitIndex &gt; parent.bitIndex) {</span>
<span class="fc" id="L2219">                child.parent = parent;</span>
            }
        }

        // Fix H's parent and child Nodes
        {
            // If H is a parent of its left and right child
            // then change them to P
<span class="fc bfc" id="L2227" title="All 2 branches covered.">            if (h.left.parent == h) {</span>
<span class="fc" id="L2228">                h.left.parent = p;</span>
            }

<span class="fc bfc" id="L2231" title="All 2 branches covered.">            if (h.right.parent == h) {</span>
<span class="fc" id="L2232">                h.right.parent = p;</span>
            }

            // Change H's parent
<span class="fc bfc" id="L2236" title="All 2 branches covered.">            if (h.parent.left == h) {</span>
<span class="fc" id="L2237">                h.parent.left = p;</span>
            } else {
<span class="fc" id="L2239">                h.parent.right = p;</span>
            }
        }

        // Copy the remaining fields from H to P
        //p.bitIndex = h.bitIndex;
<span class="fc" id="L2245">        p.parent = h.parent;</span>
<span class="fc" id="L2246">        p.left = h.left;</span>
<span class="fc" id="L2247">        p.right = h.right;</span>

        // Make sure that if h was pointing to any uplinks,
        // p now points to them.
<span class="fc bfc" id="L2251" title="All 2 branches covered.">        if (isValidUplink(p.left, p)) {</span>
<span class="fc" id="L2252">            p.left.predecessor = p;</span>
        }

<span class="fc bfc" id="L2255" title="All 2 branches covered.">        if (isValidUplink(p.right, p)) {</span>
<span class="fc" id="L2256">            p.right.predecessor = p;</span>
        }
<span class="fc" id="L2258">    }</span>

    /**
     * Returns the {@link java.util.Map.Entry} whose key is closest in a bitwise XOR
     * metric to the given key. This is NOT lexicographic closeness.
     * For example, given the keys:
     *
     * &lt;ol&gt;
     * &lt;li&gt;D = 1000100
     * &lt;li&gt;H = 1001000
     * &lt;li&gt;L = 1001100
     * &lt;/ol&gt;
     *
     * If the {@link org.apache.commons.collections4.Trie} contained 'H' and 'L', a lookup of 'D' would
     * return 'L', because the XOR distance between D &amp;amp; L is smaller
     * than the XOR distance between D &amp;amp; H.
     *
     * @param key  the key to use in the search
     * @return the {@link java.util.Map.Entry} whose key is closest in a bitwise XOR metric
     *   to the provided key
     */
    public Map.Entry&lt;K, V&gt; select(final K key) {
<span class="nc" id="L2280">        final int lengthInBits = lengthInBits(key);</span>
<span class="nc" id="L2281">        final Reference&lt;Map.Entry&lt;K, V&gt;&gt; reference = new Reference&lt;&gt;();</span>
<span class="nc bnc" id="L2282" title="All 2 branches missed.">        if (!selectR(root.left, -1, key, lengthInBits, reference)) {</span>
<span class="nc" id="L2283">            return reference.get();</span>
        }
<span class="nc" id="L2285">        return null;</span>
    }

    /**
     * Returns the key that is closest in a bitwise XOR metric to the
     * provided key. This is NOT lexicographic closeness!
     *
     * For example, given the keys:
     *
     * &lt;ol&gt;
     * &lt;li&gt;D = 1000100
     * &lt;li&gt;H = 1001000
     * &lt;li&gt;L = 1001100
     * &lt;/ol&gt;
     *
     * If the {@link org.apache.commons.collections4.Trie} contained 'H' and 'L', a lookup of 'D' would
     * return 'L', because the XOR distance between D &amp;amp; L is smaller
     * than the XOR distance between D &amp;amp; H.
     *
     * @param key  the key to use in the search
     * @return the key that is closest in a bitwise XOR metric to the provided key
     */
    public K selectKey(final K key) {
<span class="nc" id="L2308">        final Map.Entry&lt;K, V&gt; entry = select(key);</span>
<span class="nc bnc" id="L2309" title="All 2 branches missed.">        if (entry == null) {</span>
<span class="nc" id="L2310">            return null;</span>
        }
<span class="nc" id="L2312">        return entry.getKey();</span>
    }

    private boolean selectR(final TrieEntry&lt;K, V&gt; h, final int bitIndex,
                            final K key, final int lengthInBits,
                            final Reference&lt;Map.Entry&lt;K, V&gt;&gt; reference) {

<span class="nc bnc" id="L2319" title="All 2 branches missed.">        if (h.bitIndex &lt;= bitIndex) {</span>
            // If we hit the root Node and it is empty
            // we have to look for an alternative best
            // matching node.
<span class="nc bnc" id="L2323" title="All 2 branches missed.">            if (!h.isEmpty()) {</span>
<span class="nc" id="L2324">                reference.set(h);</span>
<span class="nc" id="L2325">                return false;</span>
            }
<span class="nc" id="L2327">            return true;</span>
        }

<span class="nc bnc" id="L2330" title="All 2 branches missed.">        if (!isBitSet(key, h.bitIndex, lengthInBits)) {</span>
<span class="nc bnc" id="L2331" title="All 2 branches missed.">            if (selectR(h.left, h.bitIndex, key, lengthInBits, reference)) {</span>
<span class="nc" id="L2332">                return selectR(h.right, h.bitIndex, key, lengthInBits, reference);</span>
            }
<span class="nc bnc" id="L2334" title="All 2 branches missed.">        } else if (selectR(h.right, h.bitIndex, key, lengthInBits, reference)) {</span>
<span class="nc" id="L2335">            return selectR(h.left, h.bitIndex, key, lengthInBits, reference);</span>
        }
<span class="nc" id="L2337">        return false;</span>
    }

    /**
     * Returns the value whose key is closest in a bitwise XOR metric to
     * the provided key. This is NOT lexicographic closeness!
     *
     * For example, given the keys:
     *
     * &lt;ol&gt;
     * &lt;li&gt;D = 1000100
     * &lt;li&gt;H = 1001000
     * &lt;li&gt;L = 1001100
     * &lt;/ol&gt;
     *
     * If the {@link org.apache.commons.collections4.Trie} contained 'H' and 'L', a lookup of 'D' would
     * return 'L', because the XOR distance between D &amp;amp; L is smaller
     * than the XOR distance between D &amp;amp; H.
     *
     * @param key  the key to use in the search
     * @return the value whose key is closest in a bitwise XOR metric
     * to the provided key
     */
    public V selectValue(final K key) {
<span class="nc" id="L2361">        final Map.Entry&lt;K, V&gt; entry = select(key);</span>
<span class="nc bnc" id="L2362" title="All 2 branches missed.">        if (entry == null) {</span>
<span class="nc" id="L2363">            return null;</span>
        }
<span class="nc" id="L2365">        return entry.getValue();</span>
    }

    @Override
    public int size() {
<span class="fc" id="L2370">        return size;</span>
    }

    @Override
    public SortedMap&lt;K, V&gt; subMap(final K fromKey, final K toKey) {
<span class="nc" id="L2375">        return new RangeEntryMap(fromKey, toKey);</span>
    }

    /**
     * Finds the subtree that contains the prefix.
     *
     * This is very similar to getR but with the difference that
     * we stop the lookup if h.bitIndex &gt; lengthInBits.
     */
    TrieEntry&lt;K, V&gt; subtree(final K prefix, final int offsetInBits, final int lengthInBits) {
<span class="fc" id="L2385">        TrieEntry&lt;K, V&gt; current = root.left;</span>
<span class="fc" id="L2386">        TrieEntry&lt;K, V&gt; path = root;</span>
        while (true) {
<span class="fc bfc" id="L2388" title="All 4 branches covered.">            if (current.bitIndex &lt;= path.bitIndex || lengthInBits &lt;= current.bitIndex) {</span>
<span class="fc" id="L2389">                break;</span>
            }

<span class="fc" id="L2392">            path = current;</span>
<span class="fc bfc" id="L2393" title="All 2 branches covered.">            if (!isBitSet(prefix, offsetInBits + current.bitIndex, offsetInBits + lengthInBits)) {</span>
<span class="fc" id="L2394">                current = current.left;</span>
            } else {
<span class="fc" id="L2396">                current = current.right;</span>
            }
        }

        // Make sure the entry is valid for a subtree.
<span class="pc bpc" id="L2401" title="1 of 2 branches missed.">        final TrieEntry&lt;K, V&gt; entry = current.isEmpty() ? path : current;</span>

        // If entry is root, it can't be empty.
<span class="pc bpc" id="L2404" title="1 of 2 branches missed.">        if (entry.isEmpty()) {</span>
<span class="nc" id="L2405">            return null;</span>
        }

<span class="fc" id="L2408">        final int endIndexInBits = offsetInBits + lengthInBits;</span>

        // if root &amp;&amp; length of root is less than length of lookup,
        // there's nothing.
        // (this prevents returning the whole subtree if root has an empty
        //  string and we want to lookup things with &quot;\0&quot;)
<span class="pc bpc" id="L2414" title="1 of 4 branches missed.">        if (entry == root &amp;&amp; lengthInBits(entry.getKey()) &lt; endIndexInBits) {</span>
<span class="fc" id="L2415">            return null;</span>
        }

        // Found key's length-th bit differs from our key
        // which means it cannot be the prefix...
<span class="fc" id="L2420">        if (isBitSet(prefix, endIndexInBits - 1, endIndexInBits)</span>
<span class="fc bfc" id="L2421" title="All 2 branches covered.">                != isBitSet(entry.key, lengthInBits - 1, lengthInBits(entry.key))) {</span>
<span class="fc" id="L2422">            return null;</span>
        }

        // ... or there are less than 'length' equal bits
<span class="fc" id="L2426">        final int bitIndex = getKeyAnalyzer().bitIndex(prefix, offsetInBits, lengthInBits,</span>
<span class="fc" id="L2427">                                                       entry.key, 0, lengthInBits(entry.getKey()));</span>

<span class="pc bpc" id="L2429" title="1 of 4 branches missed.">        if (bitIndex &gt;= 0 &amp;&amp; bitIndex &lt; lengthInBits) {</span>
<span class="nc" id="L2430">            return null;</span>
        }

<span class="fc" id="L2433">        return entry;</span>
    }

    @Override
    public SortedMap&lt;K, V&gt; tailMap(final K fromKey) {
<span class="nc" id="L2438">        return new RangeEntryMap(fromKey, null);</span>
    }

    @Override
    public Collection&lt;V&gt; values() {
<span class="fc bfc" id="L2443" title="All 2 branches covered.">        if (values == null) {</span>
<span class="fc" id="L2444">            values = new Values();</span>
        }
<span class="fc" id="L2446">        return values;</span>
    }

    /**
     * Serializes this object to an ObjectOutputStream.
     *
     * @param out the target ObjectOutputStream.
     * @throws IOException thrown when an I/O errors occur writing to the target stream.
     */
    private void writeObject(final ObjectOutputStream out) throws IOException {
<span class="fc" id="L2456">        out.defaultWriteObject();</span>
<span class="fc" id="L2457">        out.writeInt(this.size());</span>
<span class="pc bpc" id="L2458" title="1 of 2 branches missed.">        for (final Entry&lt;K, V&gt; entry : entrySet()) {</span>
<span class="nc" id="L2459">            out.writeObject(entry.getKey());</span>
<span class="nc" id="L2460">            out.writeObject(entry.getValue());</span>
<span class="nc" id="L2461">        }</span>
<span class="fc" id="L2462">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>